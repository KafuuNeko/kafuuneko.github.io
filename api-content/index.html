{"posts":[{"title":"Windows下VSCode使用clangd插件获得智能提示","content":" 本篇博客基于Windows下使用VSCode调试C/C++ 一、关于为什么选择clangd而不是微软的C/C++扩展 clangd相较于C/C++扩展占用资源更少，拥有更高效的代码补全、代码跳转、更直观的补全和提示。 二、安装clangd拓展 打开VSCode，在侧边栏选择扩展，搜索clangd并安装 三、配置clangd拓展 打开用户配置：在VSCode按下快捷键CTRL + SHIFT + P，输入'&gt;open user settings json' 将以下内容拷贝进json 注意事项：在拷贝之前请先确认json中是否已经存在clangd.path和clangd.arguments项目，若已存在则直接在已经存在的项上修改 关于更多的clangd.arguments参数请参考clangd文档 //clangd.path项示例：&quot;clangd.path&quot;: &quot;C:\\\\mingw64\\\\bin\\\\clangd.exe&quot; &quot;clangd.path&quot;: &quot;在上一个教程中的clangd的安装路径\\\\bin\\\\clangd.exe&quot;, &quot;clangd.arguments&quot;: [ &quot;--log=verbose&quot;, &quot;--pretty&quot;, &quot;--all-scopes-completion&quot;, &quot;--completion-style=bundled&quot;, &quot;--cross-file-rename&quot;, &quot;--header-insertion=iwyu&quot;, &quot;--header-insertion-decorators&quot;, &quot;--background-index&quot;, &quot;--clang-tidy&quot;, &quot;--clang-tidy-checks=cppcoreguidelines-*,performance-*,bugprone-*,portability-*,modernize-*,google-*&quot;, &quot;-j=2&quot;, &quot;--pch-storage=disk&quot;, &quot;--function-arg-placeholders=false&quot;, &quot;--compile-commands-dir=build&quot; ], 按下ctrl + s保存修改，并重启VSCode，至此配置完成 ","link":"https://kafuuneko.me/post/b0C7rYVvJ/"},{"title":"Windows下使用VSCode调试C/C++","content":" 本教程面向C/C++初学者，提供VSCode最简便的C/C++学习环境，因此只安装必要的编译器以及ide确保可运行代码查看效果，关于智能提示或有项目需求的请自行查阅clangd、cmake教程。 一. 请抛弃贵校古老且难用的VC6.0拥抱更现代化的ide VSCode官网：https://code.visualstudio.com/ 进入后VSCode官网点击Download按钮下载VSCode安装包并安装 注意事项：安装路径最好不要有中文或其它非ASCII字符 二. 配置LLVM/Clang编译环境 Clang是基于LLVM的C/C++/Objective-C编译器 32位版：Github 64位版：Github 点击上方超链接即可下载一套完整的编译环境(GCC 12.2.0+LLVM/Clang/LLD/LLDB 14.0.6+MinGW-w64 10.0.0) 下载完成后请解压压缩包，并在解压路径找到mingw64文件夹，将其拷贝到C盘根目录下（或者其它路径无中文名的位置） 按下快捷键Windows + E打开文件浏览器，右击‘此电脑’并选择属性 进入‘高级系统设置 在‘高级’选项卡选择‘环境变量’ 在系统变量找到‘Path’并双击进入环境变量编辑页面 添加您mingw64中的bin路径 如果您的mingw64存储在C盘根目录下，则您要添加的路径为：C:\\mingw64\\bin 完成以上步骤后确定即完成编译环境配置 三. VSCode配置 运行VSCode，并在拓展选项卡搜索Code Runner并安装 安装完成后点击管理按钮进入拓展设置 找到'Code-runner: Run In Terminal'选项并勾选 完成以上操作后关闭设置，并使用快捷键 Ctrl+N 创建一个新文件，键入测试代码后使用快捷键Ctrl + S 保存到任意目录（注意选择保存类型为c或c++），完成保存操作后在代码编辑页面内右击鼠标选择Run Code（或者使用快捷键Ctrl + Alt + N）运行代码。 ","link":"https://kafuuneko.me/post/jk0VwAoB4/"},{"title":"BVD for Android - Bilibili视频下载器","content":"支持功能： 支持下载BV、AV、EP、SS 转换下载视频的封装格式为mp4或flv 提取视频音频文件 注意事项： 下载720p以上清晰度的视频需要登录Bilibili账户 下载4k或需要大会员的视频需要登录的Bilibili账户开通大会员 请勿未经视频上传者授权擅自转载视频 部分视频下载需视频上传者授权 本软件基于GPL3.0开源协议开源：Github 下载地址：Github releases 软件截图： ","link":"https://kafuuneko.me/post/U47kbdCG5/"},{"title":"Bilibili BV-AV号转换 Java版","content":"import java.math.BigInteger; import java.util.HashMap; import java.util.Map; /** * Bilibili BV-AV转换工具 * * @author kafuu(kafuuneko@gmail.com) * * @version 1.0.0 * */ public class BvConvert { final static String mBvCode; final static Map&lt;Character, Integer&gt; mBvIntegerMap; static { mBvCode = &quot;fZodR9XQDSUm21yCkr6zBqiveYah8bt4xsWpHnJE7jL5VG3guMTKNPAwcF&quot;; mBvIntegerMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; mBvCode.length(); ++i) { mBvIntegerMap.put(mBvCode.charAt(i), i); } } final static BigInteger mBvBase = BigInteger.valueOf(58); final static BigInteger mBvXor = BigInteger.valueOf(177451812L); final static BigInteger mBvOffset = BigInteger.valueOf(8728348608L); final static int[] mBvBitMap = new int[] {4, 2, 6, 1, 8, 9}; /** * bv转为av * * @param bv Bv号，固定长度为12位(例如：BV1A4411N7Kb) * * @return 此Bv所对应的Av号，如果Bv号长度不等于12将返回null * * */ public static String bv2av(String bv) { if (bv.length() != 12) { return null; } BigInteger av = BigInteger.valueOf(0); for (int index : mBvBitMap) { BigInteger inc = BigInteger.valueOf(mBvIntegerMap.get(bv.charAt(index + 2))); av = av.multiply(mBvBase).add(inc); } return av.subtract(mBvOffset).xor(mBvXor).toString(); } /** * av转bv * */ public static String av2bv(String av) { char[] bv = &quot;BV1xx4x1x7xx&quot;.toCharArray(); BigInteger x = new BigInteger(av); x = x.xor(mBvXor).add(mBvOffset); for (int i = mBvBitMap.length - 1; i &gt;=0 ; --i) { bv[mBvBitMap[i] + 2] = mBvCode.charAt(x.mod(mBvBase).intValue()); x = x.divide(mBvBase); } return new String(bv); } } ","link":"https://kafuuneko.me/post/u72hUfUFP/"},{"title":"记Windows下CLion启动错误address already in user: bind解决方案","content":"解决方案： 重置Winsock或重启Winnat 重置： netsh winsock reset 重启： net stop winnat net start winnat ","link":"https://kafuuneko.me/post/ZkVUQJ-ZX/"},{"title":"C++ argument-dependent lookup 实参依赖查找","content":"C++实参依赖查找英文缩写为ADL，在查找无限定函数（包括对重载运算符的隐式函数调用）时，通常无限定名字查找所考虑的作用域和命名空间之外，还在其各个实参的命名空间中查找这些函数，例如: namespace ns1 { template&lt;class T&gt; void foo(T) { std::cout &lt;&lt; &quot;ns1::foo&quot; &lt;&lt; std::endl; } struct X {}; } ns1::X x; foo(x); //全局命名空间并没有定义foo，但ADL会继续在实参的命名空间中查找 //因为这个实参的类型是ns1::X，所以会继续在ns1命名空间中查找foo 实参依赖查找使得使用定义于不同命名空间的运算符成为可能，例如 namespace ns1 { struct X { int32_t value; }; const X operator+(const X &amp;lhs, const X &amp;rhs) { return X { lhs.value + rhs.value }; } } ns1::X x1{10}, x2{20}; auto x3 = x1 + x2; //等价于 x3 = operator+(x1, x2); //全局命名空间中没有operator+(const X&amp;, const X&amp;) //但因为实参属于ns1命名空间，所以ADL会检验ns1命名空间，并找到operator+(const X&amp;, const ADL 是在泛型代码中为交换两个对象而建立的手法能成立的原因： using std::swap; swap(obj1, obj2); namespace ns1 { struct Object { ... void swap(Object &amp;obj) noexcept; ... }; void swap(Object &amp;lhs, Object &amp;rhs) noexcept { lhs.swap(rhs); } } template&lt;class T&gt; void foo(T &amp;obj1, T &amp;obj2) { using std::swap; swap(obj1, obj2); //无限定函数（未使用名字空间修饰） //根据ADL，此swap可以在T所属的命名空间中匹配函数 //若无匹配的函数，将调用标准库版swap(std::swap) } int32_t a = 1, b = 2; Object obj1, obj2; foo(a, b); //调用的是std::swap foo(obj1, obj2); //调用的是ns1::swap(Object &amp;lhs, Object &amp;rhs) 参考： 实参依赖查找 Argument-dependent name lookup - Wikipedia ","link":"https://kafuuneko.me/post/QLZW03Oxn/"},{"title":"Effective 智能指针","content":" 条款18：使用std::unique_ptr管理具备专属所有权的资源 在默认情况下std::unique_ptr和裸指针有着相同的尺寸，对于大多数操作（包括提领），它们都是精确地执行裸相同地指令 自定义析构器后，若析构器是函数指针，那么std::unique_ptr的尺寸一般会增加一到两个字长。若析构器是函数对象，则带来的尺寸变化取决于该函数对象中存储裸多少状态。这意味着当一个自定义析构器既可以用函数，又可以用无捕获的lambda表达式来实现时，lambda表达式是更好的选择： //使用无状态lambda表达式作为自定义析构器 auto delInvmt1 = [](Investment* pInvestment) { makeLogEntry(pInvestment); delete pInvestment; } //返回值尺寸于Investment*相同 template&lt;typename... Ts&gt; std::unique_ptr&lt;Investment, decltype(delInvmt1)&gt; makeInvestment(Ts&amp;&amp;... args); //使用函数作为自定义析构器 void delInvmt1(Investment* pInvestment) { makeLogEntry(pInvestment); delete pInvestment; } //返回值尺寸等于Investment*的尺寸加上至少函数指针的尺寸 template&lt;typename... Ts&gt; std::unique_ptr&lt;Investment, void(*)(Investment*)&gt; makeInvestment(Ts&amp;&amp;... args); std::unique_ptr的API被设计成与使用形式相匹配。比如单个对象形式不提供索引运算符(operator[])，儿数组形式则不提供提领运算符(operator*和operator→) std::unique_ptr可以方便高效地转换为std::shared_ptr template&lt;typename... Ts&gt; std::unique_ptr&lt;Investment, decltype(delInvmt1)&gt; makeInvestment(Ts&amp;&amp;... args) { ... } std::shared_ptr&lt;Investment&gt; sp = makeInvestment( arguments ); 条款19：使用std::shared_ptr管理具备共享所有权的资源 std::shared_ptr可以通过访问某资源的引用计数来确定是否自己是最后一个指涉到该资源的 这种引用计数的方法会带来一些性能影响 std::shared_ptr的尺寸是裸指针的两倍。因为它们内部既包含一个指涉到该资源的裸指针，也包含一个指涉到该资源的引用计数的裸指针 引用计数的内存必须动态分配。 引用计数的递增和递减必须是原子操作。 对于std::shared_ptr，析构器并不是型别的一部分 auto loggingDel = [](Widget *pw) { ... } //在unique_ptr中，析构器是其型别的一部分 std::unique_ptr&lt;Widget, decltype(loggingDel)&gt; upw(new Widget, loggingDel); //但对于std::shared_ptr来说，析构器并不是它型别的一部分 std::shared_ptr&lt;Widget&gt; spw(new Widget, loggingDel); //因此拥有不同析构器的unique_ptr并不是同一类型，而拥有不同析构器的shared_ptr可以是同一种类型 自定义析构器不会改变std::shared_ptr的尺寸。无论析构器是什么型别，std::shared_ptr对象的尺寸都相当于裸指针的两倍 每一个std::shared_ptr管理的对象都有一个控制块。除了包含引用计数之外，如果该自定义析构器被指定的话，该控制块还包含自定义析构器的一个复制。如果指了一个自定义内存分配器，控制块也会包含一份它的复制。控制块还可能包含其他附加数据，包括如条款21提到的一个被称之为弱计数的次级引用计数，但我们在本条款中将忽略此类数据 - 一个对象的控制块由创建首个指涉到该对象的std::shared_ptr的函数来确定。至少应该是这样运作。毕竟，正在创建指涉到某个对象的std::shared_ptr的函数无从得知是否有其他的std::shared_ptr已经指涉到该对象的，因此，控制块的创建遵循来以下规则 - std::make_shared总是创建一个控制块，该控制块会包含指涉到T Object对象的指针(参考上图) - 从具备专属所有权的指针（即std::unique_ptr或std::auto_ptr指针）除法构造一个std::shared_ptr时，会创建一个控制块。因为专属所有权指针不存在控制块（作为构造过程的一部分，std::shared_ptr被指定来其所指涉到的对象所有权，因此那个专属所有权智能指针会被置空） - 当std::shared_ptr构造函数使用裸指针作为实参来调用时，它会创建一个控制块。如果想从一个已经拥有控制块的对象出发来创建一个std::shared_ptr，你大概会传递一个std::shared_ptr或std::weak_ptr而非裸指针作为构造函数实参，使用这两智能指针作为实参，则不会创建新的控制块，因为它们可以依赖传入的智能指针以指涉到任意所需的控制块 - 这些规则会导致一个后果：从同一个裸指针出发来构造不止一个std：：shared_ptr的话会产生未定义行为。因为这么一来，被指涉到的对象将会有多重的控制块。多重控制块意味着多重引用计数，而多重引用计数意味着该对象将被析构多次（每个引用计数会导致一次析构）。这意味着，如下所示的代码会是行不通的： ```cpp auto pw = new Widget; std::shared_ptr&lt;Widget&gt; spw1(pw, loggingDel);//为*pw创建来一个控制块 std::shared_ptr&lt;Widget&gt; spw2(pw, loggingDel);//为*pw创建来第二个控制块 //double free ``` - 要避免这些问题，首先，尽可能避免将裸指针传递给一个std::shared_ptr的构造函数。常用的替代手法是使用std::make_shared。然而在上述例子中，由于使用裸自定义析构器，这么一来就无法使用std::shared_make了。其次，如果必须将一个裸指针传递给std::shared_ptr，就直接传递new运算符的结果，而非传递一个裸指针变量 ```cpp std::shared_ptr&lt;Widget&gt;(new Widget, loggingDel);//直接传递new表达式 ``` - 使用裸指针作为std::shared_ptr构造函数实参时，会有一种令人吃惊的方式导致涉及this指针的多重控制块。 ```cpp //假设我们的程序使用std::shared_ptr来托管Widget对象，并且有个数据结构用来追踪被处理的Widget std::vector&lt;std::shared_ptr&lt;Widget&gt;&gt; processedWidgets; //假设Widget有个成员函数来做这种处理 class Widget { public: ... void process(); ... }; //对Widget::process而言，有一种看似合理的方法来完成跟踪操作 void Widget::process() { processedWidgets.emplace_back(this); //错误的做法！将处理完的Widget放入vector } //这代码能通过编译，但它把一个裸指针（this）传入了一个std::shared_ptr容器 //由此构造的std::shared_ptr将其所指涉的Widget型别对象(*this)创建一个新的控制块 //如果已指涉到该Widget型别的对象的成员函数外部再套层std::shared_ptr auto sp = std::shared_ptr&lt;Widget&gt;(); sp-&gt;process(); //未定义行为，目前sp指涉到的对象有两个控制块 ``` - 针对上面的问题，我们可以使用std::enable_shared_from_this安全的由this指针创建一个std::shared_ptr ```cpp class Widget: public std::enable_shared_from_this&lt;Widget&gt; { public: ... void process(); ... }; //安全的实现方法 void Widget::process() { processedWidgets.emplace_back(shared_from_this()); } auto sp = std::shared_ptr&lt;Widget&gt;(); sp-&gt;process();//没问题 ``` - 为避免用户在std::shared_ptr指涉到该对象前就调用了引发shared_from_this的成员函数，继承自std::enable_shared_from_this的类通常会将其构造函数声明为private访问层级，并且只允许用户通过调用返回std::shared_ptr的工厂函数来创建对象。例如，Widget看起了可能会长这样 ```cpp class Widget: public std::enable_shared_from_this&lt;Widget&gt; { public: template&lt;typename... Ts&gt; static std::shared_ptr&lt;Widget&gt; create(Ts&amp;&amp;... params); ... private: Widget() = default; }; ``` - 在典型情况下，在使用了默认构造器和默认内存分配器，并且std::shared_ptr是由std::make_shared创建的前提下，控制块尺寸只有三个字长，并且分配操作实质上没有任何成本（这些成本都被并入至所指涉的地哦下的内存分配中去了） - std::shared_ptr的API仅被设计用来处理指涉到单个对象的指针。并没有所谓的std::shared_ptr&lt;T[]&gt;。声明一个智能指针指涉到一个非智能的数组通常标志着设计的拙劣，一方面，std::shared_ptr并未提供operator[]，这么一来，要取得数组的下标，就要基于指针算术的笨拙表达式。另一方面，std::shared_ptr支持派生类到基类的指针型别转换，这对当个对象而言是有意义的，但当应用到数组时，它就会在型别系统上开天窗（也正因如此，std::shared_ptr&lt;T[]&gt;的API禁止此型别的转换） 条款20：对于类似std::shared_ptr但有可能空悬但指针使用std::weak_ptr std::weak_ptr像std::shared_ptr那样运作，但又不影响其指涉对象但引用计数 std::weak_ptr不能提领，也不能检查是否为空。这是因为std::weak_ptr并不是一种独立但智能指针，而是std::shared_ptr的一种扩充，一般都是通过std::shared_ptr来创建的。 auto spw = std::make_shared&lt;Widget&gt;(); std::weak_ptr&lt;Widget&gt; wpw(spw); //wpw和spw指涉到同一个Widget，引用计数保持为1 spw = nullptr; //引用计数变成0，Widget对象被析构。wpw空悬。 //std::weak_ptr的空悬，也被称之为失效(expired)。可以直接测试： if(wpw.expired()) ... //若wpw不再指涉到任何对象 但通常你想要但效果是：校验一个std::weak_ptr是否已经失效，如果尚未失效，就访问它所指涉到到对象。这个想起来容易，做起来难。由于std::weak_ptr缺乏提领操作，撰写不出这样到代码。即便这样的代码能够撰写出来，将校验和提领分离也会带来竞险：在expired的调用和提领操作之前，另一个线程可能重新赋值或析构最后一个指涉到该对象到std::shared_ptr，而这会导致该对象被析构。在此情况下，提领会引发未定义行为。 //综上，我们需要一个原子操作来完成std::weak_ptr是否失效但校验 //以及在未失效但条件下提供所指涉到到对象到访问 //这个操作可以由std::weak_ptr创建std::shared_ptr来实现 std::shared_ptr&lt;Widget&gt; spw1 = wpw.lock(); //若wpw失效，则spw1为空 auto spw2 = wpw.lock(); //同上，但使用auto //另一种形式是用std::weak_ptr作为实参来构造std::shared_ptr。若失效，则抛出异常 std::shared_ptr&lt;Widget&gt; spw3(wpw); //若wpw失效，抛出std::bad_weak_ptr型别但异常 std::weak_ptr可能到用武之地包括缓存、观察者列表，以及避免std::shared_ptr指针环路 条款21：优先选用std::make_unique和std::make_shared，而非直接使用new std::make_shared是C++11的一部分，但std::make_unique不是。若要在C++11中使用std::make_unique，则需要自行编写： template&lt;typename T, typename... Ts&gt; std::unique_ptr&lt;T&gt; make_unique(Ts&amp;...params) { return std::unique_ptr&lt;T&gt;(new T(std::forward&lt;Ts&gt;(params)...)); } //不要把你的版本放入std名字空间，因为当升级到C++14标准库实现时，你不会想让它和供应商提供的版本产生冲突 std::make_unique和std::make_shared是三个make系列函数中的两个。make系列函数会把一个任意实参集合完美转发给动态分配内存对象的构造函数，并返回一个指涉到该对象到智能指针。make系列函数到第三个是std::allocate_shared。它到行为和std::make_shared一样，只不过它的第一个实参是个用以动态分配内存的分配器对象 软件工程一个重要的原则：代码冗余应当避免。源代码中的重复会增加编译遍数，导致臃肿的目标代码，并且通常会产生更难上手的代码存根（code base）。它会演化成不一致的代码，而代码存梗终端不一致经常性导致代码缺陷。 auto upw1(std::make_unique&lt;Widget&gt;()); //使用make系列函数 std::unique_ptr&lt;Widget&gt; upw2(new Widget); //不使用make系列函数 Widget被重复写了两遍 auto upw1(std::make_shared&lt;Widget&gt;()); //使用make系列函数 std::make_shared&lt;Widget&gt; upw2(new Widget); //不使用make系列函数 Widget被重复写了两遍 使用make系列函数第二个原因与异常安全有关 假设我们有一个函数依据某个优先级来处理一个Widget对象 void processWidget(std::shared_ptr&lt;Widget&gt; spw, int priority); 现在假设有一个函数用来计算相对优先级 int computePriority(); 我们在processWidget的调用中用到了该函数，并且这调用中，processWidget使用了new运算符，而非std::make_shared processWidget( std::shared_ptr&lt;Widget&gt;(new Widget), computePriority() //潜在到资源泄漏 ); 在processWidget到调用过程中，下列事件必须在processWidget开始执行前发生： 表达式“new Widget”必须先完成评估求值，即，一个Widget对象必须在堆上创建 由new产生到裸指针到托管对象std::shared_ptr的构造函数必须执行 computePriority必须运行 编译器不必按照上述顺序来生成代码。“new Widget”必须在std::shared_ptr的构造函数得到调用前执行完毕，因为new表达式的结果将用做构造函数的实参之一。但是computePriority却可以在上述两个调用之前、之后，甚至，在极端情况下，会在上述两个调用之间执行。也就是说，编译器可能会放出这样的代码，以按如下时许执行操作 实施“new Widget” 执行computePriority 运行std::shared_ptr构造函数 如果生成来这样的代码，并且运行前computePriority产生来异常，那么由第一步动态分配的Widget会被泄漏，因为它将永远不会被存储在第三步才接管的std::shared_ptr中去。使用std::make_shared就可以避免这个问题（对于其它两个make同样适用）。 processWidget(std::make_shared&lt;Widget&gt;(), computePriority()); //std::make_shared和computePriority中肯定会有一个首先被调用 //如果std::make_shared被首先调用，那么指涉到动态分配到Widget到裸指针会在computePriority被调用前就被安全存储在返回到std::shared_ptr对象中 //如果是computePriority被首先调用，那么Widget还未被动态分配，所以即便出现异常也不会造成内存泄漏 std::make_shared与直接使用new表达式传递给构造函数相比，是性能的提升。使用std::make_shared会让编译器有机会利用更简洁的数据结构产生更小更快的代码（同样适用于std::allocated_shared） std::shared_ptr&lt;Widget&gt; spw(new Widget); //上面这段代码会引发两次内存分配，一次是分配Widget，另一个是分配控制块 auto spw = std::make_shared&lt;Widget&gt;(); //而这段代码只会分配一次内存，std::make_shared会分配单块内存 //既保存来Widget对象又保存来与之相关联的控制块 //处理内存分配，在释放时使用make_shared构造的shared_ptr也只需要执行一次delete 无法使用或者不推荐使用make系列函数的场景 需要使用自定义析构器 使用大括号初始化物来创建指涉到对象到指针 auto upv = std::make_unique&lt;std::vector&lt;int&gt;&gt;(10, 20); //这会创建出一个包含10个元素、每个元素值都是20的std::vector //因为make系列函数里，对形参进行完美转发对代码使用对是圆括号而非大括号 //如果想使用make系列函数来完美转发大括号初始化物对话，在条款30也给出来一个变通对方案 auto initList = {10, 20}; auto upv = std::make_unique&lt;std::vector&lt;int&gt;&gt;(initList); std::shared_ptr不使用于自定义了自身版本对operator new和operatpr delete的对象 通常情况下，类自定义这两种函数被设计成仅用来分配和释法该类精确尺寸的内存块。例如，Widget类的operator new和operator delete被设计用做处理尺寸恰好是sizeof(Widget)的内存块。而std::allocate_shared所要求的内存数量并不等于动态分配的内存尺寸，而是该尺寸的基础加上控制块的尺寸。 尺寸较大的对象，并且有std::weak_ptr指涉到该对象 由于std::make_shared将控制块和它托管到对象放在同一块内存上分配。当对象的引用计数变为0时，对象被析构。然而，托管对象所占用的内存直到与其关联的控制块也被析构时才会释法，因为同一动态分配的内存块同时包含来两者。 如前所述，控制块中还有个弱引用计数。std::weak_ptr通过检查控制块里的引用计数（而非弱计数）来校验自己是否失效。假如引用计数为0，则std::weak_ptr则失效 由于std::weak_ptr会指涉到某个控制块（即，弱计数大于0），该控制块肯定会持续存在。而由于控制块到存在，包含它到内存肯定会持续存在。这么一来，通过对应于std::shared_ptr的make系列函数所分配的内存在最后一个std::shared_ptr和最后一个指涉到它到std::weak_ptr都被析构前，无法得到释放 对于不适合使用make系列函数到情况，为了避免异常安全问题，就要确保你直接使用new表达式到时候，立即将表达式到结果传递给智能指针构造函数 std::shared_ptr&lt;Widget&gt; spw(new Widget, cusDel); processWidget(spw, computePriority());//正确，但并非最优优化 //由于processWidget里的shared_ptr参数是按值传递的，而spw是个左值 //所以在调用processWidget时会产生一次复制构造 //而复制一个std::shared_ptr要求对其引用计数进行一次原子递增操作（这会造成性能损失） //因此我们需要将它进行移动 processWidget(std::move(spw), computePriority()); //性能最优解 条款22：使用Pimpl习惯用法时，将特殊成员函数的定义放到实现文件中 Pimpl习惯用法（“pointer to implementation”，即指涉到实现到指针），就是把某类的数据成员用一个指涉到某实现类（或结构体）的指针替代，然后把原来在主类中的数据成员放置到实现类中，并通过指针间接访问这些数据成员 //widget.h class Widget { public: Widget(); private: std::string name; std::vector&lt;double&gt; data; Gadget g1, g2, g3; //某种用户自定义类型 }; 因为Widget到数据成员属于std::string、std::vector和Gadget等多种型别，这些型别所对应到头文件必须存在，Widget才能通过编译，这就说明Widget的客户必须#include 、，以及gadget.h。这些头文件增加类Widget的客户的编译时间，此外，它们也使得这些客户依赖于这些头文件内容。假如某个头文件的内容发生类改变，则Widget客户必须重新编译。 以下是C++98中的Pimpl习惯用法，使用了裸指针、裸new运算符和裸delete运算符，在C++11以及以上版本中这违背了“优先选用智能指针”的条款 //widget.h class Widget { public: Widget(); ~Widget(); private: struct Impl; Impl *pImpl; }; //widget.cpp #include &quot;widget.h&quot; #include &quot;gadget.h&quot; #include &lt;string&gt; #include &lt;vector&gt; struct Widget::Impl { std::string name; std::vector&lt;double&gt; data; Gadget g1, g2, g3; }; Widget::Widget() : pImpl(new Impl) {} Widget::~Widget() { delete pImpl; } 因此，在C++11及其以上版本中，我们需要使用std::unique_ptr替代裸指针 //widget.h #include &lt;memory&gt; class Widget { public: Widget(); private: struct Impl; std::unique_ptr&lt;Impl&gt; pImpl; }; //widget.cpp #include &quot;widget.h&quot; #include &quot;gadget.h&quot; #include &lt;string&gt; #include &lt;vector&gt; struct Widget::Impl { std::string name; std::vector&lt;double&gt; data; Gadget g1, g2, g3; }; Widget::Widget() : pImpl(std::make_unique&lt;Impl&gt;()) {} Widget的析构函数不复存在了。因为我们无需再为其撰写代码，当unique_ptr被析构时，它会自动析构它所指涉到到对象，但遗憾的是，这段代码甚至最平凡的客户代码都不能通过编译 #include &lt;widget.h&gt; Widget w; //错误！无法通过编译 因为我们使用了unique_ptr，而在主类中，我们未声明析构函数。所以编译器为我们自动生成了一个析构函数。在这个析构函数中使用了std::unique_ptr的默认析构器。默认析构器是在std::unique_ptr内部使用了delete运算符来针对裸指针实施析构函数。然而，在实施delete运算符之前，典型的实现会使用C++11中的static_assert去确保裸指针未指涉到非完整型别。这么一来，当编译器为Widget w的析构函数产生代码时，通常就会遇到一个失败的static_assert，从而导致了错误信息的产生。这个此外信息和w被析构的位置有关，因为Widget的析构函数于其编译器产生的特种成员函数一样，基本上隐式inline的。 //unique_ptr默认析构器实现 template &lt;class _Tp&gt; struct default_delete&lt;_Tp[]&gt; { private: ... template &lt;class _Up&gt; typename _EnableIfConvertible&lt;_Up&gt;::type operator()(_Up* __ptr) const _NOEXCEPT { static_assert(sizeof(_Tp) &gt; 0, &quot;default_delete can not delete incomplete type&quot;); static_assert(!is_void&lt;_Tp&gt;::value, &quot;default_delete can not delete void type&quot;); delete[] __ptr; } }; 为解决这一问题，只需要保证生成析构std::unique_ptrWidget::Impl代码处的Widget::Impl是个完整的型别即可。只要型别的定义可以被看到，它就是完整的。而Widget::Impl的定义位于widget.cpp中。因此，成功编译的关键在于让编译器看到Widget的析构函数的函数体的位置在widget.cpp内部的Widget::Impl定义之后 //widget.h #include &lt;memory&gt; class Widget { public: Widget(); ~Widget(); private: struct Impl; std::unique_ptr&lt;Impl&gt; pImpl; }; //widget.cpp #include &quot;widget.h&quot; #include &quot;gadget.h&quot; #include &lt;string&gt; #include &lt;vector&gt; struct Widget::Impl { std::string name; std::vector&lt;double&gt; data; Gadget g1, g2, g3; }; Widget::Widget() : pImpl(std::make_unique&lt;Impl&gt;()) {} Widget::~Widget() {} //或 Widget::~Widget() = default; 当在Widget中声明了析构函数，那么编译器将不会自动产生移动操作，即使默认生成的移动操作的行为完全正确，假如你需要支持移动操作，就必须自己声明该函数。既然编译器产生的版本是正确的，你很有可能尝试如下实现： //widget.h class Widget { public: ... Widget(Widget&amp;&amp; rhs) = default; Widget&amp; operator=(Widget&amp;&amp; rhs) = default; ... }; 这种手法会导致和类中没有声明析构函数一样的问题，产生该问题的基本原因也相同。编译器生成的移动赋值操作需要在重新赋值前析构pImpl指涉到到对象，但在Widget但头文件里pImpl指涉到的是非完整型别。move构造函数处问题的原因有所不同，这里的问题在于，编译器会在move构造函数内抛出异常的事件中生成析构pImpl的代码，而对于pImpl析构要求Impl具备完整型别 由于产生的原因一如此前，修复手法也如法炮制，把移动操作的定义移入实现文件内： //widget.h #include &lt;memory&gt; class Widget { public: Widget(); ~Widget(); Widget(Widget&amp;&amp; rhs); Widget&amp; operator=(Widget&amp;&amp; rhs); private: struct Impl; std::unique_ptr&lt;Impl&gt; pImpl; }; //widget.cpp #include &quot;widget.h&quot; #include &quot;gadget.h&quot; #include &lt;string&gt; #include &lt;vector&gt; struct Widget::Impl { std::string name; std::vector&lt;double&gt; data; Gadget g1, g2, g3; }; Widget::Widget() : pImpl(std::make_unique&lt;Impl&gt;()) {} Widget::~Widget() = default; Widget::Widget(Widget&amp;&amp; rhs) = default; Widget::Widget&amp; operator=(Widget&amp;&amp; rhs) = default; 编译器不会为像std::unique_ptr那样的只移型别生成复制操作，如果Widget需要支持复制操作，则需要自己撰写： //widget.h #include &lt;memory&gt; class Widget { public: Widget(); ~Widget(); Widget(Widget&amp;&amp; rhs); Widget&amp; operator=(Widget&amp;&amp; rhs); Widget(const Widget &amp;rhs); Widget&amp; operator=(const Widget &amp;rhs); private: struct Impl; std::unique_ptr&lt;Impl&gt; pImpl; }; //widget.cpp #include &quot;widget.h&quot; #include &quot;gadget.h&quot; #include &lt;string&gt; #include &lt;vector&gt; struct Widget::Impl { std::string name; std::vector&lt;double&gt; data; Gadget g1, g2, g3; }; Widget::Widget() : pImpl(std::make_unique&lt;Impl&gt;()) {} Widget::~Widget() = default; Widget::Widget(Widget&amp;&amp; rhs) = default; Widget::Widget&amp; operator=(Widget&amp;&amp; rhs) = default; Widget::Widget(const Widget &amp;rhs) : pImpl(std::make_unique&lt;Impl&gt;(*(rhs.pImpl))) { } Widget&amp; Widget::operator=(const Widget &amp;rhs) { pImpl = std::make_unique&lt;Impl&gt;(*(rhs.pImpl)); return *this; } 上述建议仅适用于std::unique_ptr，并不适用std::shared_ptr。因为对于std::shared_ptr而言，析构器型别是智能指针的一部分，这使得编译器会产生更小尺寸的运行期代码。如此高效带来的后果是，欲使用编译器生成特种函数（例如，析构函数或移动函数），就要求其指涉到到型别必须是完整型别。而对于std::shared_ptr而言，析构器型别并非智能指针到一部分，这就需要更大尺寸到运行期数据结构以及更慢一些的目标代码，但在使用编译器生成但特种函数时，其指涉到到型别却并不要求是完整型别 ","link":"https://kafuuneko.me/post/CN9VKjnkc/"},{"title":"Unity Hub安装编辑器validation failed(验证失败)错误解决方案","content":" 等待下载完成，出现“validation failed”时，不要关闭Unity Hub 手动创建文件夹：C:\\Program Files\\Unity\\Hub\\Editor 回到Unity Hub，点击刷新 https://forum.unity.com/threads/install-failed-validation-failed.1147151/ ","link":"https://kafuuneko.me/post/vsgUEzDTX/"},{"title":"适用于树莓派4b的Java16","content":"Download Or: wget https://github.com/AdoptOpenJDK/openjdk16-binaries/releases/download/jdk16u-2021-05-08-12-45/OpenJDK16U-jdk_arm_linux_hotspot_2021-05-08-12-45.tar.gz ","link":"https://kafuuneko.me/post/INOc7XxL0/"},{"title":"C++ 奇异递归模板模式(Curiously recurring template pattern)","content":" 什么是CRTP？ CRTP的性质 从模板类继承 将派生类本身用做基础类的模板参数 例如： template &lt;typename T&gt; class Base { ... }; class Derived : public Base&lt;Derived&gt; { ... }; 这样做的目的是使用基础类中的派生类，相较于虚函数实现的多态，CRTP节约了动态绑定虚函数查询的开支 template&lt;class T&gt; class Base { public: void call() { static_cast&lt;T*&gt;(this)-&gt;foo(); } }; class Derived : public Base&lt;Derived&gt; { public: void foo() { std::cout &lt;&lt; &quot;Derived class member was invoked&quot; &lt;&lt; std::endl; } }; CRTP的使用陷阱 如果两个类同时继承自同一个CRTP就矿难导致CRTP尝试使用错误的类，造成未定义的行为 class Derived1 : public Base&lt;Derived1&gt; { ... }; class Derived2 : public Base&lt;Derived1&gt; // Base&lt;Derived1&gt; 出现问题 { ... }; 可以将基础类的构造函数的访问权限设置为私有的，并将模板类设置为友元即可解决 template&lt;class T&gt; class Base { public: // ... private: Base() {} friend T; }; class Derived1 : public Base&lt;Derived1&gt; { ... }; class Derived2 : public Base&lt;Derived1&gt; // 此时编译将无法通过 { ... }; //因为派生类的构造器必须调用基类的构造函数，但由于基类中的构造函数是私有的，因此除了友元以外都无法访问它 //而基类唯一的友元类是模板类，因此，如果派生类与模板类不同，则代码将无法通过编译 CRTP的另一个陷阱就算派生类中的方法会以隐藏相同名称的基类方法。因此，不要在基类和派生类中具有相同的名称 CRTP的部分用途 对不同的派生类进行单独的计数 template&lt;class T&gt; struct Counter { static uint32_t count; Counter(){ ++count; } ~Counter() { --count; } }; template&lt;class T&gt; uint32_t Counter&lt;T&gt;::count{ 0 }; class A : public Counter&lt;A&gt; { }; class B : public Counter&lt;B&gt; { }; int main() { A a1{}, a2{}; B b1{}; std::cout &lt;&lt; &quot;存在&quot; &lt;&lt; A::count &lt;&lt; &quot;个A对象&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;存在&quot; &lt;&lt; B::count &lt;&lt; &quot;个B对象&quot; &lt;&lt; std::endl; return 0; } //print //存在2个A对象 //存在1个B对象 静态多态 template&lt;class T&gt; struct Counter { static uint32_t count; Counter(){ ++count; } ~Counter() { --count; } void print() { static_cast&lt;T*&gt;(this)-&gt;sub_print(); } }; template&lt;class T&gt; uint32_t Counter&lt;T&gt;::count{ 0 }; struct A : public Counter&lt;A&gt; { void sub_print() { std::cout &lt;&lt; &quot;存在&quot; &lt;&lt; count &lt;&lt; &quot;个A对象&quot; &lt;&lt; std::endl; } }; struct B : public Counter&lt;B&gt; { void sub_print() { std::cout &lt;&lt; &quot;存在&quot; &lt;&lt; count &lt;&lt; &quot;个B对象&quot; &lt;&lt; std::endl; } }; template&lt;class T&gt; void print_counter(Counter&lt;T&gt; &amp; c) { c.print(); } int main() { A a1{}, a2{}; B b1{}; print_counter(a1); print_counter(b1); return 0; } 复用功能 有些类提供了通用功能，可能被许多类重复使用 //假设有两个类，分别为长方形和正方形，它们都有一个计算面积的成员函数 class rectangle { public: rectangle() { } double get_heigh() { ... } double get_width() { ... } double calc_area() { return get_heigh() * get_width(); } ... }; class square { public: square() { } double get_heigh() { ... } double get_width() { ... } double calc_area() { return get_heigh() * get_width(); } ... }; //其中计算面积的成员函数是通用的 //将通用的成员函数在基类中实现，并在使用到此成员函数的类中继承此基类 template&lt;class T&gt; class rect { public: double calc_area() { T &amp;derived = static_cast&lt;T&amp;&gt;(*this); return derived.get_heigh() * derived.get_width(); } private: friend T; rect() { } }; class rectangle : public rect&lt;rectangle&gt; { public: rectangle() { } double get_heigh() { ... } double get_width() { ... } ... }; class square : public rect&lt;square&gt; { public: square() { } double get_heigh() { ... } double get_width() { ... } ... }; 多态链 //例如有一个ButtonDialog 继承自Dialog类 //ButtonDialog支持设置对话框按钮类型(set_button_type) class Dialog { template&lt;class T&gt; Dialog&amp; show(const T &amp;message) { ... return *this; } template&lt;class T&gt; Dialog&amp; set_title(const T &amp;title) { ... return *this; } }; class ButtonDialog : Dialog { ButtonDialog&amp; set_button_type(ButtonType type) { ... return *this; } }; //考虑下面的代码 ButtonDialog().set_title(&quot;Hi&quot;).set_button_type(ButtonType.cancel).show(); //首先ButtonDialog().set_title(&quot;Hi&quot;)调用的是基类中的set_title，它返回了一个Dialog 引用 //接着调用set_button_type，但Dialog中无法找到这个成员函数，故调用失败 //所以可以利用CRTP，改成下面这样 template&lt;class DerivedT&gt; class Dialog { template&lt;class T&gt; DerivedT&amp; show(const T &amp;message) { ... return *this; } template&lt;class T&gt; DerivedT&amp; set_title(const T &amp;title) { ... return *this; } }; class ButtonDialog : Dialog&lt;ButtonDialog&gt; { ButtonDialog&amp; set_button_type(ButtonType type) { ... return *this; } }; //没问题 ButtonDialog().set_title(&quot;Hi&quot;).set_button_type(ButtonType.cancel).show(); 参考资料 https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern https://www.fluentcpp.com/2017/05/12/curiously-recurring-template-pattern/ ","link":"https://kafuuneko.me/post/KqvHFouCX/"},{"title":"Effective 转向现代C++","content":" 条款7：在创建对象时注意区分()和{} 大括号初始化对解析语法(vexing parse)免疫。C++规定：任何能够解析为声明的都要解析为声明，而这会带来副作用，程序员本来想要以默认方式构造一个对象，但却一不小心声明了一个函数，例如： Widget w1(10); //调用Widget的构造函数，传入形参10 Widget w2(); //!!声明了一个返回值型别为Widget的函数，这显然不是我们想要的 Widget w3{}; //调用没有形参的Widget构造函数 大括号禁止内建型别之间进行隐式窄化型别的转换(narrowing conversion)。如果大括号内的表达式无法保证能够采用进行初始化的对象来表达。则代码不能通过编译 double x, y, z; int sum1 {x + y + z};//错误！double之和可能无法用int表达 int sum2 (x + y + z);//没问题(表达式的值被截断为int) int sum3 = x + y + z;//同上 在构造函数重载决议期间，只要有任何可能，大括号初始化物就会与带有std::initializer_list型别的形参相匹配，即使其他重载版本有着貌似更加匹配的形参表 使用小括号还是大括号，会造成的结果大相径庭的一个例子是：使用两个实参来创建一个std::vector&lt;数值型别&gt;对象 在模板内容进行对象创建时，到底应使用小括号还是大括号会成为一个棘手的问题，例如： //以任意数量的实参来创建一个任意型别的对象 template&lt;class T, class Ts&gt; void doSomeWork(Ts&amp;&amp; ...params) { T localObject(std::forward&lt;Ts&gt;(params)...);//使用小括号 T localObject{std::forward&lt;Ts&gt;(params)...};//使用大括号 } doSomeWork&lt;std::vector&lt;int&gt;&gt;(10, 20); //如果doSomeWork在创建localObject时使用了小括号，结果会得到一个包含10个元素的std::vector //如果doSomeWork在创建localObject时使用了大括号，结果会得到一个包含10和20两个元素的std::vector //哪个才是对的呢？doSomeWork不可能下这个判断，只有调用者有决定权 //这正是标准库函数std::make_shared和std::make_unique所面临的问题 //而这些函数解决问题的办法时在内部使用了小括号，并把这个决定以文档的形式广而告之 条款8：优先选用nullptr，而非0或NULL 相对于0或NULL，优先选用nullptr，可以避免整数和指针型别之间重载 void f1(Widget* pw) { ... } template&lt;class T&gt; void f2(T pw) { f1(pw); } f2(0); // T被推导为int型，编译器禁止int型隐式转换为指针型，所以无法通过编译 f2(nullptr); // T被推导为nullptr_t，通过编译 条款9：优先选用别名声明，而非typedef 别名名称在处理涉及函数指针型别时，比较容易理解 typedef void (*FP)(int, const std::string&amp;); //等价于 using FP = void (*)(int, const std::string&amp;); 别名名称可以模板化，typedef不行 template&lt;class T&gt; using MyAllocList = std::list&lt;T, MyAlloc&lt;T&gt;&gt;; MyAllocList&lt;Widget&gt; lw; //如果非要使用typedef的话，就需要从头自己动手了 template&lt;class T&gt; struct MyAllocList { typedef std::list&lt;T, MyAlloc&lt;T&gt;&gt; type; }; MyAllocList&lt;Widget&gt;::type lw; 别名模板可以令人免写“::type”后缀，并且在模板内，对于内嵌typedef的引用要求加上typename后缀 //如果要在模板内使用typedef来创建一个链表，它容纳的对象型由别的模板形参指定的话，那就需要给typedef的名字加一个typename前缀 template&lt;class T&gt; class Widget { //带依赖型别必须前面加一个typename //因为此时编译器并不确定MyAllocList&lt;T&gt;::type命名了一个型别，可能是别的东西，例如是一个数据成员 typename MyAllocList&lt;T&gt;::type list; }; //如果MyAllocList是由别名模板定义的，那么就不需要写typename声明了 template&lt;class T&gt; class Widget { //此处MyAllocList&lt;T&gt;是型别模板，他必然命名了一个型别。 //综上，MyAllocList&lt;T&gt;是个非依赖性类别，所以typename既不需要也不允许 MyAllocList&lt;T&gt; list; }; C++11以型别特征的形式给了程序员以执行此类变换的工具。类别特征是在头文件&lt;type_traits&gt;给出的一整套模板。其中一些用于执行变换功能用途 std::remove_const&lt;T&gt;::type std::remove_reference&lt;T&gt;::type std::add_lvalue_reference&lt;T&gt;::type //在C++14中，他们有对应的别名模板 std::remove_const_t&lt;T&gt; std::remove_reference&lt;T&gt; std::add_lvalue_reference&lt;T&gt; //如果想要在C++11中使用其对应的别名模板，则自己声明即可 template&lt;T&gt; using remove_const_t = typename std::remove_const&lt;T&gt;::type; template&lt;T&gt; using remove_reference_t= typename std::remove_reference&lt;T&gt;::type; template&lt;T&gt; using add_lvalue_reference_t= typename std::add_lvalue_reference&lt;T&gt;::type; 条款10：优先选用限定作用的域的枚举型别，而非不限作用域的枚举型别 如果在一对大括号里声明一个名字，则该名字的可见性就被限定在括号括起来的作用域内。但这个规则不适用于C++98风格的枚举型别定义的枚举量。这些枚举量的名字属于包含着这个枚举型别的作用域，这就意味着此作用域内不能有其他实体取相同的名字 enum Color { black, white, red }; auto white = false; //错误！white已在范围内被声明了 这些枚举量的名字泄露到枚举型别所在的作用域的这一事实，催生了此类枚举型别的官方术语：不限定的(un scoped)枚举型别。它们在C++中的对等物，限定作用域的(scoped)枚举型别，却不会以这样的方式泄露名字 enum class Color { black, white, red }; auto white = false; // 没问题，范围内并无其他“white” Color c = white; // 错误！范围内无名为“white”的枚举量 Color c = Color::white; // 没问题 auto c = Color::white; // 同样没问题，并且符合条款5的建议 由于限定作用域的枚举类型是通过“enum class”声明的，所以它们也被称为枚举类 限定作用域的枚举型别，现在称之为不限范围的枚举型别 限定作用域的枚举型别仅在枚举型别内可见。它们只能通过强制类型转换以转换至其他型别 限定作用域的枚举型别和不限范围的枚举型别都支持底层型别指定。限定作用域的枚举型别的默认底层型别是int，而不限范围的枚举型别没有默认底层型别 限定作用域的枚举型别总是可以进行前置声明，而不限范围的枚举型别却只有在指定了默认底层型别的前前提下才可以进行前置声明 条款11：优先选用删除函数，而非private未定义函数 删除函数无法通过任何方法使用，所以即便是成员和友元函数中的代码也无法使用一个被删除了的函数 习惯上，删除函数会被声明为public，而非private。因为把新函数声明为public会得到较好的错误信息 任何函数都能成为删除函数，但只有成员函数能声明成private //假定有一个非成员函数 bool isLucky(int n); //C++的C渊源决定了可以凑合看作数值的型别都可以隐式转换为int，但有些调用尽管可以编译但语义上却了无意义 if(isLucky('a')) ... //‘a’是幸运数吗？ if(isLucky(true)) ... //&quot;true&quot;又如何？ if(isLucky(3.5)) ... //是不是应该先截断为3再检查是否为幸运数？ //在删除函数后 bool isLucky(char) = delete; bool isLucky(bool) = delete; bool isLucky(double) = delete; if(isLucky('a')) ... //错误！ if(isLucky(true)) ... //错误！ if(isLucky(3.5)) ... //错误！ if(isLucky(2)) ... //正确 //综上：尽管删除函数不可被使用，但它们还是程序的一部分。 //因此，它们在重载决议时还是会纳入考量 删除函数可以阻止那些不应该进行的模板具现，而private不行 //假设需要一个和内建指针协作的模板 template&lt;class T&gt; void processPointer(T* ptr); //指针中有两个异类，一个是void*指针，因为无法对起执行提领、自增、自减等操作。 //还有一个是char*指针，因为它们基本上表示的是C风格的字符串，而不是指涉单个字符串的指针。 //我们假定这样的特殊处理手法是在采用这两个型别时拒绝调用。 //只需要删除这些具现 template&lt;&gt; void processPointer&lt;void&gt;(void*) = delete; template&lt;&gt; void processPointer&lt;char&gt;(char*) = delete; //那么如果使用void*和char*调用是非法的，那么很有可能使用const void*和const char*也是非法的 //所以基本上这些具实也该删除 template&lt;&gt; void processPointer&lt;const void&gt;(const void*) = delete; template&lt;&gt; void processPointer&lt;const char&gt;(const char*) = delete; //如果要来个斩草除根，你还需要删除const volatile void *和const volatile char* //这些重载版本，还有那些指涉到其他标准库字符型别的指针的重载版本 //这些字符型包括：std::wchar_t、std::char16_t和std::char32_t 如果是类内部的函数模板，并且你想通过private声明禁用某些具现是做不到的 //如果是类内部的函数模板，并且你想通过private声明来禁用某些实现，这是做不到的 //因为你不可能给予成员函数模板的特化以不同于主模板的访问层级 class Widget { public: template&lt;class T&gt; void processPointer(T* ptr) { ... } private: template&lt;&gt; void processPointer&lt;void&gt;(void*); //错误！！ }; //问题在于，模板特化是必须在名字空间作用域而非基类作用域内撰写的 //这个毛病在删除函数身上就不会表现出来，因为一来它们根本不需要不同的访问层级 //二来也因为成员函数模板可以在类外被删除 class Widget { public: template&lt;class T&gt; void processPointer(T* ptr) { ... } }; template&lt;&gt; //仍然具备public访问层级，但被删除了 void Widget::processPointer&lt;void&gt;(void*) = delete; 条款12：为意在改写的函数添加override声明 由于改写(override)和重载(overload)读起来很像，尽管是两个毫不相干的概念，我们还是要澄清，正是虚函数改写，使得基类接口派生类函数成为了可能 class Base { public: virtual void doWork(); //基类中的虚函数 }; class Derived: public Base { public: virtual void doWork(); //改写了Base::doWirj }; 而如果要这个改写动作真的发生，有一系列要求必须满足 基类中的函数必须是虚函数 基类和派生类中的函数名字必须完全相同(析构函数例外) 基类和派生类的函数形参类别必须完全相同 基类和派生类中的函数属性常量(constness)必须完全相同 基类和派生类中的函数返回值和异常规格必须完全相同 基类和派生类中的函数引用饰词(reference qualifier)必须完全相同（C++11） 成员函数引用饰词使得对于左值和右值对象(*this)的处理能够区分开来 条款13：优先选用const_iterator，而非iterator const_iterator指涉到不可被修改的值。只要有可能就应该使用const的标准实践声明，任何时候只要你需要应该迭代器而其指涉到的内容没有修改必要，你就应该使用const_iterator 这一点对于C++98和C++11都成立，但在C++98中，const_iterator得到的支持不够全面。建立它们不容易，而建立好了以后使用它们的方式也受限。例如： std::vector&lt;int&gt; values; ... //这里使用iterator并非正确选择，因为代码中并无任何地方修改了iterator指涉的内容 std::vector&lt;int&gt;::iterator it = std::find(values.begin(), values.end(), 1993); values.insert(it, 1998); //可是在C++98中，要将这段代码修改为const_iterator要废很大功夫 //下面是一种概念上貌似站得住脚的途径，但其实并不正确： typedef std::vector&lt;int&gt;::iterator IterT; typedef std::vector&lt;int&gt;::const_iterator ConstIterT; std::vector&lt;int&gt; values; ... ConstIterT ci = std::find(static_cast&lt;ConstIterT&gt;(values.begin()), static_cast&lt;ConstIterT&gt;(values.end()), 1983); values.insert(static_cast&lt;IterT&gt;(ci), 1998); //可能无法通过编译，理由见下 //因为values是C++98中的非const容器 //而并没有什么简单的方法能从一个非const容器得到其对应的const容器 //所以在std::find调用语句中使用了强制类型转换，将非const迭代器转换为const迭代器 //还有一些别的方法取得对应的const容器，例如可以绑定到一个引用到const的变量，再在find中使用这个变量 //而在C++98中，插入和删除的位置只能以iterator指定，而不接受const_iterator //而从const_iterator到iterator并不存在可移植的型别转换(就算C++11也是如此) C++11中，使用const_iterator变的非常容易。容器的成员函数cbegin和cend都返回了const_iterator型别，并且STL成员函数若要取用指示位置的迭代器，它们也要求使用const_iterator型别。 std::vector&lt;int&gt; values; ... auto it = std::find(values.cbegin(), values.cend(), 1993); values.insert(it, 1998); 只有在想撰写最通用化的库代码的时候，C++11对于const_iterator的支持显得不够充分。这些代码会考虑到某些容器、或类似容器的数据结构会以非成员函数的方式提供begin和end(还有cbegin、cend和rbegin等)，而不是以成员函数的方式。举例来说，刚才我们写的这段代码可以写成下面findAndInsert模板的通用形式 template&lt;typename C, typename V&gt; void findAndInsert(C&amp; container, const V&amp; targetVal, const V&amp; insertVal) { using std::cbegin; using std::cend; auto it = std::find(cbegin(container), cend(container), targeValue); container.insert(it, insertVal); } //以上代码在C++14中可以运行，但在C++11中不行。因为C++11中没有cbegin、cend、rbegin、rend、crbegin和crend //但你可以在C++11中很容易实现这些缺失的模板 template&lt;class C&gt; auto cbegin(const C&amp; container)-&gt;decltype(std::begin(container)) { return std::begin(container); } //这个cbegin模板接受了一个形参C，实参型别可以是任何表示类似容器的数据结构 //并通过其引用到const型别的形参container来访问该实参。如果C对应一个传统容器型别(例如：vector&lt;int&gt;) //则container就是该容器型别的引用到const的版本(例如：const vector&lt;int&gt;&amp;) //调用（C++11提供的）非成员函数版本的begin函数并传入一个const容器会产生一个const_iterator //而模板返回的正是这个迭代器 条款14：只要函数不会发射异常，就为其加上noexcept声明 在C++11形成过程中，逐渐达成了一个共识，那就是关于函数发射异常这件事，真正只要的信息是它到底会不会发射，非黑即白。当你明明知道一个函数不会发射异常却未给它加上noexcept声明的话，这就算接口规格缺陷！ 相对于不带noexcept声明的函数，带有noexcept声明的函数有更多机会得到优化 //考察一下C++98和C++11在表达函数不会发射异常时的差异。 //考虑一个函数f，欲向调用方暴躁它们不会接收到异常 int f(int x) throw(); //f不会发射异常：C++98风格 int f(int x) noexcept; //f不会发射异常：C++11风格 //如果，在运行期间，一个异常逸出f的作用域，则f的异常规则被违反 //在C++98异常规格下，调用栈会开解至f的调用方，然后执行一些与本条款无关的动作后，程序执行中止 //而在C++11异常规格下，运行期行为会稍有不同：程序中止前，栈只是可能会开解 在带有noexcept声明的函数中，优化器不需要在异常传出函数的前提下，将执行期栈保持在可开解状态；也不需要在异常溢出函数的前提下，保证所有其中的对象以其被构造的顺序逆序完成析构。而那些以“throw()”异常规格声明的函数就享受不到这样的优化灵活性 noexcept性质对于移动操作、swap、函数释放函数和析构函数最有价值 关于移动操作 当向std::vector型别对象添加新的元素时，可能会空间不够(即std::vector型别对象的尺寸(size)和其容量(capacity)相等)。当这件事发生时，std::vector型别对象会分配一个新的、更大的内存块(chunk)来存储元素，然后将现存的内存块复制到新内存 在C++98中，这种转移的做法是先把元素逐个从旧内存复制到新内存，然后将旧内存中的对象析构。这个做法使得push_back能够提供异常安全保证：如果在复制元素的过程中抛出了异常，则std::vector型别对象会保持原样不变，因为在旧内存中的元素直至所有的元素被成功复制入新内存后才会被析构 而在C++11中，针对std::vector型别对象元素的复制操作替换为了移动操作，这样违法了push_back的强异常安全保证：假如移动到第n+1个元素时抛出了异常，n个元素以及从其中移出。恢复到原始状态可能不行，因为把对象逐个移回原始内存这个动作本身可能存在异常 因为遗留的代码可能依赖于push_back的强异常安全保证，这么一来C++11的实现就半年一声不吭地把push_back内部的复制操作全部采用移动替代，除非它知道移动操作不会发射异常。所以std::vector::push_back以及C++98中其他因为强异常安全保证的函数(std::vector::reserve、std::deque::insert等)利用了“能移动则移动，必须复制才复制”的策略 关于swap 标准库中的swap是否带有noexcept声明取决于用户定义的swap是否带有noexcept声明。例如，标准库为数组和std::pair准备的swap函数如下： template&lt;class T, size_t N&gt; void swap(T (&amp;a)[N], T (&amp;b)[N]) noexcept(noexcept(swap(*a, *b))); template&lt;class T1, class T2&gt; struct pair { void swap(pair&amp; p) noexcept(noexcept(swap(first, p.first)) &amp;&amp; noexcept(swap(second, p.second))); }; //它们到底是不是具有noexcept性质取决于它们的noexcept分句中的表达式结果是否为noexcept noexcept声明是函数接口的组成部分 只有在保证函数实现长期居于noexcept性质的前提下，才给予noexcept 大多数函数都是异常中立的，不具备noexcept性质 异常中立的函数永远不具备noexcept性质 有些函数(尤其是移动操作和swap)具有noexcept性质的收益是如此之高，以至于只要有任何可能就应该将它们的实现加上noexcept 但不可扭曲函数的实现，使之符合noexcept的性质 在1标准容器库中，只要发现容器移动操作可能写成不抛出异常的，实现者就往往会把这些操作加上noexcept声明，即使标准并不要求他们这样做 对于某些函数来说，具备noexcept性质非常重要，所以他们默认就算这样的 在C++11中，内存释放函数和所有析构函数(无论用户定义的还是编译器自动生成的)都隐式的具备noexcept性质。 析构函数唯一未具备noexcept的场合就算所在类中有数据成员(包括继承以及在其他数据成员中包含的数据成员)的型别显式地将其析构函数声明未可能发射异常的(即未其加上了&quot;noexcept(false)&quot;声明)。这种析构函数标准库里一个也没有 有些库的接口设计者会把函数区分为带有宽松契约(wide contract)和带有狭隘契约(narrow contract)的不同种类 带有宽松契约的函数，是没有前置条件的。要调用这样的函数，无须关心程序状态，对于传入的实参也没有限制。如果你在撰写的是个带有宽松契约的函数，并且你知道它不会发射异常，那么建议给它加个noexcept声明 但对于带有狭隘契约的函数来说，情况有那么点微妙。 假设你正在撰写一个函数f，带有一个std::string型别的形参，并假设f的自然实现不会产生异常。这就说明f应该是应该noexcept声明 再假设f有个前提条件：std::string型别形参不得超过32个字符，f并无义务去校验这个前置条件，因为函数会断言前置条件一定满足。即便有前置条件，为f加上noexcept声明看上去也合情合理 但再假设f的实现者选择去校验前置条件，若前置条件不满足则抛出一个异常，但如果f已经加上了noexcept声明就不好办了，因为这么一来异常会导致程序中止 所以一般只把noexcept声明保留给那些带有宽松的契约的函数 条款15：只要有可能使用constexpr，就使用它 关于constexpr对象具备const属性，也是编译阶段就已知的(严格的说，它们的值是在翻译期间决定的) int sz; //非constexpr变量 constexpr auto arraySize1 = sz; //错误！sz的值在编译器未知 std::array&lt;int, sz&gt; data1; //错误！同上 constexpr auto arraySize2 = 10; //没问题，10是个编译器常量 std::array&lt;int, arraySize2&gt; data2; //没问题，因为arraySize2是constexpr //注意！！const并未提供和constexpr同样的保证，因为const对象不一定经由编译期已知值来初始化 int sz; //非constexpr变量 const auto arraySize = sz; //没问题，arraySize是sz的一个const副本 std::array&lt;int, arraySize&gt; data1; //错误！arraySize的值并非编译期可知 如果你想让编译器提供保证，让变量拥有一个值，用于编译期常量语境，那么能达到这个目的的工具是constexpr，而非const constexpr函数在调用时若传入的实参是编译器已知的，则会产出编译期结果 constexpr函数可以用在要求编译期常量的语境中。在这样的语境中，若你传给一个constexpr函数的实参是编译期已知的，则结果也会在编译期间计算出来。如果任意一个实参值在编译期未知，则你的代码无法通过编译 在调用constexpr函数时，若传入的值有一个或多个在编译期未知，则它的运作方式和普通函数无异，即它也是在运行期执行结果的计算。这意味着，如果函数执行的是同样的操作，仅仅应用的语境一个是要求编译期常量的，一个是用于所有其他值的话，那就不必写两个函数。constexpr函数就可以同时满足所有需求 在C++11中，constexpr函数不得包含多于一个可执行语句，但在C++14中限制条件大大地放宽了 //在C++11中用constexpr实现pow constexpr int pow(int base, int exp) noexcept { return (exp == 0 ? 1 : base * pow(base, exp - 1)); } //在C++14中用constexpr实现pow还可以这样 constexpr int pow(int base, int exp) noexcept { auto result = 1; for(int i = 0; i &lt; exp; ++i) result *= base; return result; } constexpr函数仅限于传入和返回字面型别，意思就算这样的型别能够持有编译期可以决议的值。在C++11中，所有的内建型别，除了void，都符合这个条件。但用户自定义型别同样可能也是字面型别，因为它的构造函数和其它成员函数可能也是constexpr函数 class Point { public: constexpr Point(double xVal = 0, double yVal = 0) noexcept : x(xVal), y(yVal) { } constexpr double xValue() const noexcept {return x;} constexpr double yValue() const noexcept {return y;} void setX(double newX) noexcept { x = newX; } void setY(double newY) noexcept { y = newY; } private: double x, y; }; //此处，Point的构造函数被声明为了constexpr函数，由于传入它的实参在编译期可知 //构造出来的Point对象数据成员，其值也是在编译期可知的。 //如此初始化出来的Point对象也自然具备了constexpr属性 constexpr Point p1(9.4, 27.7); //没问题，在编译期“运行”constexpr构造函数 constexpr Point p2(28.8, 5.3); //类似地，访问器xValue和yValue也可以声明为constexpr //原因在于，若它们是通过一个在编译期已知的值的Point对象，即一个constexpr Point对象来调用的话 //数据成员x和y的值就可以在编译期获知 //从而，就能撰写出这样的constexpr函数，它调用Point的访问器并使其返回结果来初始化constexpr对象 constexpr Point midpoint(const Point&amp; p1, const Point&amp; p2) noexcept { return { (p1.xValue() + p2.xValue()) / 2, (p1.yValue() + p2.yValue()) / 2 }; } constexpr auto mid = midpoint(p1, p2); //尽管在其初始化过程中涉及了构造函数、访问器、还有个非成员函数的调用，却可以在只读内存中得以创建！ //这意味着，你可以将一个诸如mid.xValue()*10的表达式运用到模板形参中，或指定枚举量的表达式中！ //因为Point::xValue返回的是double，mid.xValue()*10的型别也是double //而浮点型别固然不能用于具现模板，或指定枚举值，但却可以用诸如static_cast&lt;int&gt;的表达式来生成整数型别 在C++11中，constexpr函数都隐式地被声明为了const的了(这里是指成员函数的const饰词，意味着函数不能修改其操作对象，严格的说是不能修改其非mutable数据成员)，其次，它们的返回型别是void，而在C++11中，void并不是个字面型别。不过这两个限制在C++14中都被解除了，所以在C++14中，就连设置器也可以声明为constexpr class Point { public: ... constexpr void setX(double newX) noexcept { x = newX; } constexpr void setY(double newY) noexcept { y = newY; } ... }; //所以可以写出这样的代码 constexpr Point reflection(const Point&amp; p) noexcept { Point result; result.setX(-p.xValue()); result.setY(-p.yValue()); return result; } 条款16：保证const成员函数的线程安全性 可以肯定地说,，const成员函数都会运行在并发执行的条件下，所以你应该保证const成员函数的线程安全性，除非可以确信它们不会用在并发语境中，例如： class Polynomial { public: using RootsType = std::vector&lt;double&gt;; RootsType roots() const { if (!rootsAreValid) { //如果缓存无效，则计算根，并存入rootVals ... rootsAreValid = true; } return rootVals; } private: mutable bool rootsAreValid { false }; mutable RootsType rootVals {}; }; //从概念上来说，roots不会改变它操作的Polynomial对象 //然而作为缓存活动的组成部分，它可能需要修改rootVals和rootsAreValid的值(这是mutable的经典用例) //设想性质有两个线程同时在同一个Polynomial对象上调用roots Polynomial p; //线程1 线程2 auto rootsOfP = p.roots(); auto valsGivingZero = p.roots(); roots是一个const成员函数，这意味着它代表的是一个读操作。多个线程在没有同步的条件下执行读操作被认为是安全的，然而在本例中却并不安全。因为在roots内部，这些线程中的一个或两个可能企图更改数据成员rootsAreValid和rootVals，也就意味着这段代码可能有不同的多个线程在没有同步的情况下读写同一块内存，而着就算数据竞险(data race)，这段代码存在未定义行为 最常见且常见的解决办法就是引入一个mutex(互斥量mutual exclusion) class { ... RootsType roots() const { std::lock_guard&lt;std::mutex&gt; g(m); if (!rootsAreValid) { ... rootsAreValid = true; } return rootVals; } private: ... mutable std::mutex m; //之所以要声明为mutable，是因为加锁和解锁都不是const成员函数所为 //如果没有这么一个声明，在roots内，m就会被当作是个const对象处理 }; 但由于std::mutex是个只移型别(move-only type)，也就是只能移动但不能复制的型别，将m加入Polynomial的副作用就算Polunomial失去了可复制性 关于std::mutex以及std::lock_guard请参阅：https://zh.cppreference.com/w/cpp/thread/mutex https://zh.cppreference.com/w/cpp/thread/lock_guard 运用std::atomic型别的变量会比运用互斥量提供更好的性能，但前者仅适用对单个变量或内存区域的操作 就一些特定情况而言，可以使用成本更低的std::atomic，例如要计算一个成员函数被调用的次数 具体参阅：https://zh.cppreference.com/w/cpp/atomic/atomic class Point { public: ... double distanceFromOrigin() const noexcept { ++callCount; //带原性的自增操作 return std::sqrt((x*x) + (y*y)); } private: mutable std::atomic&lt;unsigned&gt; callCount{ 0 }; ... }; 值得注意的是std::atomic也是只移型别，与std::mutex有着相同的副作用，但开销往往较小 条款17：理解特种成员函数的生成机制 特种函数生成机制 特种成员函数指的是那些C++会自动生成的成员函数。C++98有四种特种成员函数：默认构造函数、析构函数、复制构造函数，以及复制赋值运算符。而在C++11中多了移动构造函数和移动赋值运算符 这些函数仅在需要时才会生成，也就是在某些代码使用了它们，而在类中未显式声明的场合。仅当一个类没有声明任何一个构造函数时才会默认生成构造函数 生成的特种成员函数都具有public访问层级且是inline的，除析构函数其他都是非虚的 如果位于一个派生类中，并且基类的析构函数是虚函数，在这种情况下，编译器为派生类生成的析构函数也是个虚函数 移动构造函数和移动赋值函数是“按成员移动”的，按成员移动是由两部分组成，一部分是在支持移动操作的成员是执行移动操作，另一部分是在不支持移动操作的成员上执行复制操作 移动操作不同于两种复制操作是彼此独立的，移动操作并不彼此独立：声明了其中一个，就会阻止编译器生成另一个。这种机制的理由在于，假设你声明了一个移动构造函数，你实际上表明移动操作的实现方式将会与编译器生成的默认按成员的移动构造函数多少有些不同。而若按成员进行移动构造操作有不合用之处的话，那么按成员进行移动赋值运算符极有可能也会有不合用之处。综上，声明一个移动构造函数会阻止编译器去生成移动赋值运算符，反之同理 一旦显式声明了复制操作，这个类就不会再生成移动操作。因为声明复制操作(无论是复制构造还是复制赋值)的行为表明了对象的常规复制途径(按成员复制)对于该类并不适用。编译器从而判定，既然成员复制不适用于复制操作，则按成员移动极有可能也不适用于移动操作 反之亦然，一旦声明了移动操作(无论是移动构造还是移动赋值)，编译器就会废除赋值操作(删除它们) 大三定律：如果你声明了复制构造函数、复制赋值运算符，或析构函数中的任何一个，你就得同时声明这三个。它根植于这样的思想：如果有改写复制操作的需求，往往就意味着该类需要进行某种资源管理，而这就意味着： 在一种复制操作中进行的任何资源管理，也极有可能在另一种复制操作中也需要进行 该类的析构函数也会参与到该资源的管理中 如果存在用户声明的析构函数，则平凡的按成员复制也不适于该类。根据这个推论，优酷进一步得出结论，如果声明了析构函数，则复制操作就不该被自动生成，因为它们的行为不可能正确 不过在C++98标准被接受的时代，这样的论证没有得到充分的重视，所以在C++98中，用户声明的析构函数即使存在，也不会影响编译器生成复制操作的意愿。这种情况在C++11中仍然得到了保持 由于大三律背后的理由仍然车里，在结合了复制操作就会阻止隐式生成移动构造函数的事实，就推动了C++11中的这样一个规定：只要用户声明了析构函数，就不会生成移动操作 综上，移动操作生成的条件（如果需要生成）仅当以下三者同时成立 该类未声明任何复制操作 该类未声明任何移动操作 该类未声明任何析构函数 C++11标准规定，在已存在复制操作或析构操作的条件下，仍然自动生成复制操作已经成为了被废弃的行为，如果你有一些代码已经存在任一复制操作或析构函数的条件下，仍然依赖复制操作的自动生成的话，就得考虑升级这些类。假定编译器生成的这些函数有着正确的行为（即按成员复制类的非静态数据成员正是你所需要的行为），那么可以通过“=default”来显式地表达这个想法 总而言之，在C++11中，支配特种成员函数的机制如下： 默认构造函数：与C++98的机制相同。仅当类中不包含用户声明的构造函数时才生成 析构函数：与C++98的机制基本相同，唯一的区别在于析构函数默认为noexcept。与C++98的机制相同，仅当基类的析构函数为虚时，派生类的析构函数才是虚的 复制构造函数：运行期行为与C++98相同：按成员进行非静态数据成员的复制构造。仅当类中不包含用户声明的复制构造函数时才生成。如果该类声明了移动操作，则复制构造函数将被删除。在已经存在复制赋值运算符或析构函数的条件下，仍然生成复制构造函数已经成为了被废弃的行为 复制赋值运算符：运行期行为与C++98相同：按成员进行非静态数据成员的复制赋值。仅当类中不包含用户声明的复制赋值运算符时才生成。如果该类声明了移动操作，则复制构造函数将被删除。在已经存在复制构造函数或析构函数的条件下，仍然生成复制赋值运算符已经成为了废弃的行为 移动构造函数和移动赋值运算符：都按成员进行非静态数据成员的移动操作。仅当类中不包含用户声明的复制操作、移动操作和析构函数时才生成 成员函数模板在任何情况下都不会抑制特种成员函数的生成 class Widget { ... template&lt;typename T&gt; Widget(const T&amp; rhs); //以任意型别构造Widget template&lt;typename T&gt; Widget&amp; operator=(const T&amp; rhs); //以任意型别对Widget赋值 ... }; 编译器会始终生成Widget的复制和移动操作（假定支配其生成的条件都得到了满足），即使这些模板的具现结果生成了复制构造函数或复制赋值运算符的签名（当T的值为Widget时就会发生这种情况）。条款26会告诉你，这么一个边缘场景有着至关重要的推论 ","link":"https://kafuuneko.me/post/AuPMgwCJW/"},{"title":"DJI SPARK 朝阳","content":" 原图下载 ","link":"https://kafuuneko.me/post/phsGV5Yf4/"},{"title":"Effective Auto","content":" 条款5：优先使用auto，而非显示型别声明 auto可以用来表示编译器才掌握的类别 因此可以用auto声明/存储一个闭包变量，且内存量也和该闭包一样，而使用std::function声明的、存储的一个闭包变量是std::function的一个示例，所以不管给定签名如何，它都占有固定尺寸的内存而这个尺寸对于其存储的闭包而言不一定够用，若是如此，std::function的构造函数就会分配堆上的内存来存储该闭包，且编译器的实现细节一般会限制内联，并会产生间接的函数调用，所以std::function来调用闭包几乎必然比起使用“auto”手法来得又大又慢！ 显示声明可能导致你既不想要也没想到的隐式型别转换 auto变量必须初始化，基本上对会导致兼容性和效率问题的型别不匹配的现象免疫 条款6：当auto推导的型别不符合要求时，使用带显式型别的初始化物习惯用法 有的时候，auto的推导结果与程序员所要的结果完全不同，例如下列代码 std::vector&lt;bool&gt; foo() { std::vector&lt;bool&gt; r; //... return r; } //k的值取决于std::vector&lt;bool&gt;::reference的实现 auto k = foo()[0]; //k的型别被推断为std::vector&lt;bool&gt;::reference而不是bool //有一种实现让对象含有一个指针，指涉到一个机器字，该机器字有那个被引用的比特，再加上基于那个比特对应的字的偏移量 //foo()返回一个临时对象，在“auto k = foo()[0];”此表达式完成后此对象将被析构，此时k将含有一个空悬指针，使用k将造成未定义结果 因为std::vector做过特化，用了一种压缩形式表示持有的bool元素，每个bool元素用一个比特来表示，但这种做法给operator[]带来了一个问题，因为按理来说std::vector的operator[]应该返回一个T&amp;，然而C++中禁止比特引用，所以就需要使用std::vector::reference型别代理 std::vector::reference是个代理类的实例，所谓代理类，就是为了模拟增广其他型别的类。代理类的用途广泛。比如说，std::vector::reference就是为了制造std::vector的operator[]返回了一个比特的引用假象。再比如说，标准库中的智能指针也是代理类，它们是为了将资源管理嫁接到裸指针之上 总之，隐形的代理类和auto无法和平共处，所以上面的代码应使用显式型别初始化 auto k = static_cast&lt;bool&gt;(foo()[0]);//正确写法 ","link":"https://kafuuneko.me/post/E3vQz_jt1/"},{"title":"Effective  型别推导","content":" 条款1：理解模板型别推导 template&lt;typename T&gt; void f(ParamType param); f(expression); 情况1：ParamType是个指针或引用，但不是个万能引用 若expression具有引用型别，则将引用部分忽略 然后，对expr的类型与ParamType进行模式匹配，以决定T的类型 若ParamType是引用类型也基本同上 情况2：ParamType是个万能引用(&amp;&amp;) 如果传入的expression是左值，T和ParamType都会被推导为左值引用 如果expression是个右值，则类似情况1进行推导 例如： void f(T &amp;&amp;param);//(此处T是模板) int i = 10; f(i); //推导结果⇒ void f(int &amp;param) 推导过程：因传入的expression是个左值，所以T被推导为int型左值引用(int &amp;)，紧接着(int&amp; &amp;&amp;)被折叠为(int &amp;) 情况3：ParamType既非指针也非引用 如果expression具有引用型别，则忽略引用部分 忽略const以及volatile修饰 数组实参 数组以及函数型别的实参会退化为相应的指针，除非被用来初始化引用 条款2：理解auto型别推导 auto推导和模板型别推导基本一致，其唯一的区别在于auto会假定大括号括起来的初始化表达式代表一个std::initializer_list，但模板型别推导不会 但如果模板中的参数类型为std::initializer_list，则模板推导机制会推导出T应有的型别 在函数返回值或lambda式形参中使用auto将会使用模板型别推导而非auto型别推导 条款3：理解decltype 大多数情况下，decltype会得出变量或表达式的型别而不做任何修改 因为在C++的定义中，表达式(x)也是一个左值，所以对于型别为T的左值表达式，除非该表达式仅有一个名字，decltype总是得出型别T&amp;，假设x是一个T型左值，decltype(x)推导出的类型是T而decltype((x))推导出的类型是T&amp; C++14支持decltype(auto)，表示使用decltype的推导规则进行推导 条款4：掌握查看类别推导结果的方法 使用boots的typeindex::type_id_with_cvr可以完全正确的推导结果 ","link":"https://kafuuneko.me/post/LJvcapNxG/"},{"title":"串口调试工具(DCOM)","content":"基于WPF开发的串口调试工具 发送支持字符串、文件、十六进制、二进制 支持将接收消息内容以字符串、十六进制、二进制形式呈现 支持将接收的数据保存到文件 仓库：Github 下载：DCOM ","link":"https://kafuuneko.me/post/uP-j_qepQ/"},{"title":"左倾红黑树实现及注释","content":"左倾红黑树插入结果可视化： 插入顺序:6 7 1 5 3 4 2 put:6 put:7 put:1 put:5 put:3 put:4 put:2 #include &lt;iostream&gt; #include &lt;cstdlib&gt; #include &lt;ctime&gt; template&lt;class _Key, class _Value&gt; class LLRBT { enum color_t { BLACK, RED }; struct Node { _Key key; _Value value; size_t count; //此节点所有孩子节点数+1 color_t color; //指向本节点的链接颜色 struct Node *left, *right; Node( const _Key &amp; pKey, const _Value &amp; pValue, color_t pColor = RED, size_t pCount = 1, struct Node * pLeft = nullptr, struct Node * pRight = nullptr) : key(pKey), value(pValue), count(pCount), color(pColor), left(pLeft), right(pRight) { } }; //定义根节点 Node * root_ = nullptr; void clear(Node * node) { if(node == nullptr) return; clear(node-&gt;left); clear(node-&gt;right); delete node; } //判断一个节点是否为红节点(即链接到此节点的链接颜色为红色) bool is_red(Node * node) const { return (node) ? (node-&gt;color == RED) : false; } //取节点的所有孩子节点及其自身的节点数 size_t size(Node * node) const { return (node) ? (node-&gt;count) : 0; } //判断红黑树中是否存在指定的节点 bool contains(Node * node, const _Key &amp; key) { while(node) { if (key &lt; node-&gt;key) node = node-&gt;left; else if (node-&gt;key &lt; key) node = node-&gt;right; else return true; } return false; } //取最小节点 Node * min(Node * node) { while(node &amp;&amp; node-&gt;left) node = node-&gt;left; return node; } //左旋转节点的右链接 Node * rotate_left(Node * node) { Node * p = node-&gt;right; node-&gt;right = p-&gt;left; p -&gt;left = node; p -&gt;color = node-&gt;color; node-&gt;color = RED; //更新节点数量统计 p -&gt;count = node-&gt;count; node-&gt;count = size(node-&gt;left) + size(node-&gt;right) + 1; return p; } //右旋转节点的左链接 Node * rotate_right(Node * node) { Node * p = node-&gt;left; node-&gt;left = p-&gt;right; p -&gt;right = node; p -&gt;color = node-&gt;color; node-&gt;color = RED; //更新节点数量统计 p -&gt;count = node-&gt;count; node-&gt;count = size(node-&gt;left) + size(node-&gt;right) + 1; return p; } //节点颜色转换(分解4-节点或向父节点'借'节点操作) void flip_colors(Node * node) { node-&gt;color = (node-&gt;color == RED) ? BLACK : RED; node-&gt;left-&gt;color = (node-&gt;left-&gt;color == RED) ? BLACK : RED; node-&gt;right-&gt;color = (node-&gt;right-&gt;color == RED) ? BLACK : RED; } //插入新的节点 Node * put(Node * parent, const _Key &amp; key, const _Value &amp; value) { if(!parent) return new Node(key, value, RED); if (key &lt; parent-&gt;key) parent-&gt;left = put(parent-&gt;left, key, value); else if (parent-&gt;key &lt; key) parent-&gt;right = put(parent-&gt;right, key, value); else parent-&gt;value = value; /*左节点连接是黑色，右节点连接是红色，则左转节点 左倾红黑树不允许红色链接出现在右边，若有红色链接出现在右边就进行左旋转操作 ('..'代表红色节点，'.'代表黑色节点) 3 5 .. =&gt; .. .. .. 5 3 */ if(!is_red(parent-&gt;left) &amp;&amp; is_red(parent-&gt;right)) parent = rotate_left(parent); /* 节点连接连续红色，右转节点 5 .. 3 .. ... 3 =&gt; .. .. .. 1 5 .. 1 */ if(is_red(parent-&gt;left) &amp;&amp; is_red(parent-&gt;left-&gt;left)) parent = rotate_right(parent); /* 左右连接全为红色，则将左右连接设置为红色，其父节点设为红色 3 3 ... =&gt; . . .. .. . . 1 5 1 5 */ if(is_red(parent-&gt;left) &amp;&amp; is_red(parent-&gt;right)) flip_colors(parent); //更新节点数量统计 parent-&gt;count = size(parent-&gt;left) + size(parent-&gt;right) + 1; return parent; } //恢复左倾红黑树的平衡性 Node * balance(Node * node) { //'借孩子'操作可能导致红色节点出现在右边，这在左倾红黑树中是不可以出现的，需要左旋转进行修复 if(is_red(node-&gt;right)) node = rotate_left(node); //左节点连接是黑色，右节点连接是红色，则左转节点 if(!is_red(node-&gt;left) &amp;&amp; is_red(node-&gt;right)) node = rotate_left(node); //左节点连接连续红色，右转节点 //is_red(node-&gt;left)若为红色节点则node-&gt;left必定存在 //所以此处is_red(node-&gt;left-&gt;left)是安全的 if(is_red(node-&gt;left) &amp;&amp; is_red(node-&gt;left-&gt;left)) node = rotate_right(node); //左右连接全为红色，则将左右连接设置为红色，其父节点设为红色 if(is_red(node-&gt;left) &amp;&amp; is_red(node-&gt;right)) flip_colors(node); node-&gt;count = size(node-&gt;left) + size(node-&gt;right) + 1; return node; } //借一个红色节点给左孩子 Node * move_red_left(Node * node) { //首先向父节点借一个节点 flip_colors(node); if(is_red(node-&gt;right-&gt;left)) { //它的亲兄弟节点不是2-节点，从其亲兄弟借一个节点到左节点中 node-&gt;right = rotate_right(node-&gt;right); node = rotate_left(node); } return node; } //移除最小的节点 Node * remove_min(Node * node) { if(node-&gt;left == nullptr) { delete node; return nullptr; } /* 关于删除最小节点的规则 确保当前节点不是2-节点 1.如果当前节点的左节点不是2-节点，则继续 2.如果当前节点的左节点是-2节点，且它的亲兄弟节点不是2-节点，则从其亲兄弟借一个节点到左节点中 3.如果当前节点的左节点是-2，且它的亲兄弟也是2-节点，则将父节点中的最小键及其兄弟节点合并为一个4-节点 */ if(!is_red(node-&gt;left) &amp;&amp; !is_red(node-&gt;left-&gt;left)) { //非2-节点，父亲或亲兄弟节点借一个节点给左节点，以确保左节点不是2-节点 node = move_red_left(node); } node-&gt;left = remove_min(node-&gt;left); //删除操作完成后需要由下至上分解所有4-节点 return balance(node); } //借一个节点给右孩子 Node * move_red_right(Node * node) { //同move_red_left的注释 flip_colors(node); if(is_red(node-&gt;left-&gt;left)) { node = rotate_right(node); } return node; } //移除最大的节点 Node * remove_max(Node * node) { /* 此处相较于删除最小节点多了一个步骤 若左孩子为红节点则进行右旋操作，让右节点成为红节点以便接下来的删除操作 根据左倾树的性质 若左孩子非红色节点，则必然存在有右子节点 假设此处不进行右旋，则下列例子的平衡将遭到破坏 2 .. 由于2节点的右孩子为空，所以2节点是最大节点，此时C1.0处的代码将直接 .. 删除2节点，其左节点也被被抛弃 1 */ if(is_red(node-&gt;left)) node = rotate_right(node); //C1.0 if(node-&gt;right == nullptr) { delete node; return nullptr; } if(!is_red(node-&gt;right) &amp;&amp; !is_red(node-&gt;right-&gt;left)) { node = move_red_right(node); } node-&gt;right = remove_max(node-&gt;right); //删除操作完成后需要由下至上进行恢复 return balance(node); } //将移除最小的节点和移除最大的节点实现结合在一起，即可实现删除任意节点 Node * remove(Node * node, const _Key &amp; key) { if(key &lt; node-&gt;key) { //和删除最小节点时的操作类似，判断节点的左孩子是否为2-节点，若非2-节点则需要借一个红色节点给左孩子 if(!is_red(node-&gt;left) &amp;&amp; !is_red(node-&gt;left-&gt;left)) { node = move_red_left(node); } node-&gt;left = remove(node-&gt;left, key); } else { if(is_red(node-&gt;left)) node = rotate_right(node); if(node-&gt;key == key &amp;&amp; (node-&gt;right == nullptr)) { delete node; return nullptr; } //和删除最大节点的操作类似 if(!is_red(node-&gt;right) &amp;&amp; !is_red(node-&gt;right-&gt;left)) { node = move_red_right(node); } if(node-&gt;key == key) { //找到node的后继节点 Node * minNode = min(node-&gt;right); //将后继节点的key-value移动给node node-&gt;key = std::move(minNode-&gt;key); node-&gt;value = std::move(minNode-&gt;value); //删除最小节点无需使用节点的key/value数据，只会不断向左直到最小的那个节点 node-&gt;right = remove_min(node-&gt;right); } else { node-&gt;right = remove(node-&gt;right, key); } } //删除操作完成后需要由下至上进行恢复 return balance(node); } void print(Node * node) const { if(node == nullptr) return; std::cout &lt;&lt; ((node-&gt;color == RED) ? 'R' : 'B') &lt;&lt; '(' &lt;&lt; (node-&gt;key) &lt;&lt; ')' &lt;&lt; ' '; print(node-&gt;left); print(node-&gt;right); std::cout &lt;&lt; &quot;BACK &quot;; } public: LLRBT() = default; LLRBT(const LLRBT &amp; rhs) = delete; LLRBT(const LLRBT &amp;&amp; rhs) = delete; LLRBT &amp; operator=(const LLRBT &amp; rhs) = delete; LLRBT &amp; operator=(const LLRBT &amp;&amp; rhs) = delete; ~LLRBT() { clear(root_); } void clear() { clear(root_); root_ = nullptr; } size_t size() const { return root_ ? size(root_) : 0; } void put(const _Key &amp; key, const _Value &amp; value) { root_ = put(root_, key, value); root_-&gt;color = BLACK; } _Value * get(const _Key &amp; key) const { for(Node * node = root_; node != nullptr; ) { if (node-&gt;key &lt; key) node = node-&gt;right; else if (key &lt; node-&gt;key) node = node-&gt;left; else return &amp;(node-&gt;value); } return nullptr; } void remove_min() { if(root_ == nullptr) return; if(!is_red(root_-&gt;left) &amp;&amp; !is_red(root_-&gt;right)) { root_-&gt;color = RED; } root_ = remove_min(root_); if(root_) root_-&gt;color = BLACK; } void remove_max() { if(root_ == nullptr) return; if(!is_red(root_-&gt;left) &amp;&amp; !is_red(root_-&gt;right)) { root_-&gt;color = RED; } root_ = remove_max(root_); if(root_) root_-&gt;color = BLACK; } void remove(const _Key &amp; key) { //判断树中是否存在这个key if(!contains(root_, key)) return; if(!is_red(root_-&gt;left) &amp;&amp; !is_red(root_-&gt;right)) { root_-&gt;color = RED; } root_ = remove(root_, key); if(root_) root_-&gt;color = BLACK; } void print() const { print(root_); std::cout &lt;&lt; std::endl; } }; int main() { int testCount = 7; int keys[] = {6, 7, 1, 5, 3, 4, 2}; LLRBT&lt;int, int&gt; st; for(int i = 0; i &lt; testCount; ++i) { std::cout &lt;&lt; &quot;put:&quot; &lt;&lt; keys[i] &lt;&lt; std::endl; st.put(keys[i], keys[i]); //st.print(); } for(int j = 1; j &lt;= testCount; ++j) { st.remove(j); std::cout &lt;&lt; &quot;\\nremove:&quot; &lt;&lt; j &lt;&lt; &quot;\\nsize:&quot; &lt;&lt; st.size() &lt;&lt; std::endl; for(int i = 1; i &lt;= testCount; ++i) { int * p = st.get(i); std::cout &lt;&lt; (p ? *p : 0) &lt;&lt; ' '; } std::cout &lt;&lt; std::endl; st.print(); std::cout &lt;&lt; std::endl; } std::cout &lt;&lt; std::endl; std::cin.get(); return 0; } ","link":"https://kafuuneko.me/post/cho8KcfUV/"},{"title":"Ciphertext","content":"基于QT平台以及32轮TEA加密算法的跨平台开源文本加密程序 下载地址：https://files.kafuu.cc/index.php?p=2F5265736F75726365732F43697068657274657874 项目地址：https://github.com/KafuuNeko/Ciphertext ","link":"https://kafuuneko.me/post/kERjJhAnP/"},{"title":"C++实现TEA加密算法","content":"TEA实现代码Header Only 已实现功能：自由长度字节集加解密、数据流加解密、文件加解密、字符串加解密 项目地址：https://github.com/KafuuNeko/CPPTEA ","link":"https://kafuuneko.me/post/iHUmPxM0i/"},{"title":"Pixiv图片自动爬取","content":"自动爬取指定Tag的所有图片，并将图片以及作者信息保存到本地目录./pixiv/[tag]/[id] 代码仓库 ","link":"https://kafuuneko.me/post/i3D4fXPMI/"},{"title":"STM32绘制折线统计图","content":"绘制折线统计图最关键的在于‘给定两点绘制一条线’，最简单的方法莫过于使用直线方程的斜截式y = kx + b以及 由y = kx + b =&gt; kx+b-y = 0 =&gt; kx+b-y = 0 =&gt; kx-y=-b =&gt; -kx+y = b 我们可以很轻易的使用 kx-y=-b计算出b的值，以及k=(y1 – y0) / (x1-x0)计算出k值 void DrawLine(float x0, float y0, float x1, float y1) { float k = (y1-y0) / (x1-x0); float b = -k * x0 + y0; float y = 0.0f; for(float x = x0; x &lt;= x1; x += 0.2) { y = k * x + b; y = y + 0.5; BMP[Y_SIZE-(int)y][(int)(x+0.5)] = 1; } } DDA算法 DDA算法是计算机图形学中最基础简单的绘制直线算法，其主要思想是由直线公式y = kx + b推导出来的。 在求出k和b的值的情况下，我们就能知道指定x对应的y值，由y=kx+b可知如果x值步进1，那么y就步进k+b，相同的，如果y步进1则x的步进(1-b)/k，接着向下取整即可得到要绘制的点 void DrawLineDDA(float x0, float y0, float x1, float y1) { u8 i=1; float dx, dy, length, x, y; if (fabs(x1 - x0) &gt;= fabs(y1 - y0)) length = fabs(x1 - x0); else length = fabs(y1 - y0); dx = (x1 - x0) / length; dy = (y1 - y0) / length; x = x0; y = y0; while (i&lt;=length) { BMP[Y_SIZE-(int)(y + 0.5)][(int)(x+0.5)] = 1; x = x + dx; y = y + dy; i++; } } 基于以上两种算法（任选其一），就可以很轻松的做出折线统计图了：点击查看LineChart.c ","link":"https://kafuuneko.me/post/wc2h528UJ/"},{"title":"RPN/逆波兰式","content":"逆波兰式（Reverse Polish notation，RPN，或逆波兰记法），也叫后缀表达式（将运算符写在操作数之后） https://github.com/KafuuNeko/CRPN 一.将一个普通的中缀表达式转换为逆波兰表达式 首先定义一个存储运算符的栈S，以及一个存放结果的字符串R a.接着遍历普通中缀表达式的每个字符，定义当前玻璃到的字符名称为C 若C是数字，则直接加入结果R 若C为运算符，则判断该运算符类型 1.若为右括号’)’，则不断弹出栈S中的符号输出至结果，直至遇到左括号 2.若为左括号'(‘，则直接将此运算符加入到栈S 3.若为数学运算符(+, -, , /, %)则判断运算符优先级 最低优先级：左括号'(‘ 第二优先级：+ - 第一优先级： / % 接着获取栈S顶栈运算符的优先级，若顶栈运算符优先级大于或等于C运算符优先级，则弹出栈S顶栈运算符，加入至结果R，并重复此步骤，直至栈S顶栈运算符的优先级小于C运算符的优先级或栈S为空，接着将C运算符入栈S b.处理完表达式字符串后，如果栈S内还有残留数据，那么依次出栈，加入到结果R ExampleA：20 + 10 * 8 1[C:20]:数字直接加入结果 R=[20], S=[] 2[C:+] :运算符+，则判断栈S顶栈运算符的优先级，因为此时栈S为空，所以直接加入到栈S 运算符R=[20], S=[+] 3[C:10]:数字直接加入结果 R=[20, 10], S=[+] 4[C:] :运算符，当前栈S顶栈运算符为+，优先级低于*，所以C直接加入到栈S R=[20, 10], S=[+, *] 5[C:8] :数字直接加入结果 R=[20, 10, 8], S=[+, *] 处理完成，但此时栈不为空，则依次弹出栈内元素至结果 最终结果R=[20, 10, 8, *, +] 20 10 8 * + ExampleB：10 + 5 * (20 - 5 - 10) + 8 - 10 / 2 1[C:10] :数字直接加入结果 R=[10], S=[] 2[C:+] :运算符+，则判断栈S顶栈运算符的优先级，因为此时栈S为空，所以直接加入到栈S 运算符R=[10], S=[+] 3[C:5] :数字直接加入结果 R=[10, 5], S=[+] 4[C:] :运算符，当前栈S顶栈运算符为+，优先级低于*，所以C直接加入到栈S R=[10, 5], S=[+, *] 5[C:(] :左括号，直接将此运算符加入到栈S R=[10, 5], S=[+, *, (] 6[C:20] :数字直接加入结果 R=[10, 5, 20], S=[+, *, (] 7[C:-] :运算符-，栈S顶栈为左括号'('，因为左括号优先级小于-，所以C直接加入栈S R=[10, 5, 20], S=[+, *, (, -] 8[C:5] :数字直接加入结果 R=[10, 5, 20, 5], S=[+, *, (, -] 9[C:-] :运算符-，栈S顶栈运算符与C运算符优先级相同，弹出栈S顶栈内容至R后栈S顶栈为左括号'('，优先级小于运算符C，所以C再此时入栈S R=[10, 5, 20, 5, -], S=[+, *, (, -] 10[C:10]:数字直接加入结果 R=[10, 5, 20, 5, -, 10], S=[+, *, (, -] 11[C:)] :右括号')'，不断弹出栈S中的符号输出至结果，直至遇到左括号 R=[10, 5, 20, 5, -, 10, -], S=[+, *] 12[C:+] :运算符+，弹出栈S内所有优先级大于或等于运算符+的符号至结果R后将C入栈 R=[10, 5, 20, 5, -, 10, -, *, +], S=[+] 13[C:8] :数字直接加入结果 R=[10, 5, 20, 5, -, 10, -, *, +, 8], S=[+] 14[C:-] :运算符-，弹出栈S内所有优先级大于或等于运算符+的符号至结果R后将C入栈 R=[10, 5, 20, 5, -, 10, -, *, +, 8, +], S=[-] 15[C:10] :数字直接加入结果 R=[10, 5, 20, 5, -, 10, -, *, +, 8, +, 10], S=[-] 16[C:/] :运算符/，此时栈S顶栈运算符‘-’的优先级小于‘/’，所以C直接加入栈S R=[10, 5, 20, 5, -, 10, -, *, +, 8, +, 10], S=[-, /] 17[C:2] :数字直接加入结果 R=[10, 5, 20, 5, -, 10, -, *, +, 8, +, 10, 2], S=[-, /] 处理完成，但此时栈不为空，则依次弹出栈内元素至结果 R=[10, 5, 20, 5, -, 10, -, *, +, 8, +, 10, 2, /, -] 最终结果：10 5 20 5 - 10 - * + 8 + 10 2 / - 二.计算逆波兰表达式 计算方式十分简单，我们先定义一个存放数字的栈S 接着遍历逆波兰表达式，遇到数字则加入数字栈，遇到运算符则弹出两个数字栈顶栈数字，并使用此运算符对这两个数字进行计算，并将计算结果加入到数字栈内 ExampleA：20 10 8 * + 1[C:20] :C加入到栈S S=[20] 2[C:10] :C加入到栈S S=[20, 10] 3[C:8] :C加入到栈S S=[20, 10, 8] 4[C:*] :取出栈S顶栈两个元素 N1:8, N2:10 使用此运算符计算结果：R:N1 * N2 = 80，并将结果重新入栈 S=[20, 80] 5[C:+] :取出栈S顶栈两个元素 N1:20, N2:80 使用此运算符计算结果：R:N1 + N2 = 100，并将结果重新入栈 S=[100] 当完成这些步骤后，栈S内剩下的最后一个元素即为表达式的计算结果，如果最后栈内元素不唯一，或在遍历到运算符时栈内元素数量少于2个，则都判定为此表达式有误 ","link":"https://kafuuneko.me/post/EAk40KKHw/"},{"title":"哈夫曼(Huffman)编码","content":"哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式，哈夫曼编码是可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，该方法完全依据字符出现概率来构造异字头的平均长度最短的码字，有时称之为最佳编码，一般就叫做Huffman编码（有时也称为霍夫曼编码）。 演示源码：https://github.com/KafuuNeko/HuffmanDemo ","link":"https://kafuuneko.me/post/ozH07LlZx/"},{"title":"我的世界插件 - 雷暴之夜","content":"一.介绍 版本要求：1.15.2 Java版我的世界服务器 安装此插件后我的世界入夜将有概率触发雷暴之夜事件，在雷暴之夜，僵尸、苦力怕、蜘蛛将获得Buff，并且有大量的雷电精准落到生物上 点击这里下载雷暴之夜插件 点击插件雷暴之夜源码 二.配置 可打开MC/Thunderstorm/config.yml设置参数 probability 入夜后进入雷暴之夜的概率 precondition: thunder 进入雷暴之夜前提条件，若为true则必须在雷雨天入夜才可能进入雷暴之夜 monsters: amount 进入雷暴之夜后怪物数量 ticks 进入雷暴之夜后怪物刷新间隔 buff 进入雷暴之夜后怪物获得的buff等级 speed damage_resistance health_boost fire_resistance increase_damage absorption random_lightning interval 雷击间隔时间，单位为Tick probability: player 每次雷击玩家被雷击的概率 other 每次雷击其它生物被雷击的概率 ","link":"https://kafuuneko.me/post/CqvD9O8TI/"},{"title":"使用freessl.cn申请Let’s encrypt V2多域名通配符证书","content":"一.获取证书 进入https://freessl.cn/，选择Let’s encrypt V2，并填写域名后点击创建免费的SSL证书 接着填写您的邮箱，选择证书类型为ECC，SCR生成选择浏览器生成，接着点击点击创建 接着根据提示，为您的域名添加两条TXT记录 添加完成后点击配置完成，检测一下，若检测通过（务必等检测通过后点击验证，有时候配置DNS后生效时间可能会有点长，请耐心等待），则点击验证，若通过则下载文件 下载的压缩包内将包含两个文件：full_chain.pem以及private.key 二.SSL配置 请确保已经安装mod_ssl，如果未安装请先安装 CentOS：yum install mod_ssl 以文本打开full_chain.pem，会发现里面有两段串码，前一部分是证书，后一部分为证书链。将这个文件复制为2个文件，一个保留前一部分，做证书文件，另一个保留后一部分，做证书链文件。 创建两个文件public.pem以及chain.pem，public.pem文件内容为full_chain.pem前一段码，chain.pem文件内容为full_chain.pem后一段码 接着配置ssl.conf(/etc/httpd/conf.d)文件 # 添加 SSL 协议支持协议，去掉不安全的协议 SSLProtocol all -SSLv2 -SSLv3 # 修改加密套件如下 SSLCipherSuite HIGH:!RC4:!MD5:!aNULL:!eNULL:!NULL:!DH:!EDH:!EXP:+MEDIUM SSLHonorCipherOrder on # 证书公钥配置（如果pem只有一个，那么public为第一段码） SSLCertificateFile cert/public.pem # 证书私钥配置 SSLCertificateKeyFile cert/private.key # 证书链配置，如果该属性开头有 ‘#’字符，请删除掉（如果pem只有一个，那么chain为第第二段码） SSLCertificateChainFile cert/chain.pem 示范： &lt;VirtualHost *:443&gt; ServerName www.kafuu.cc:443 DocumentRoot &quot;/var/www/html/main/root&quot; SSLEngine on SSLProtocol all -SSLv2 -SSLv3 SSLCipherSuite HIGH:!RC4:!MD5:!aNULL:!eNULL:!NULL:!DH:!EDH:!EXP:+MEDIUM SSLHonorCipherOrder on SSLCertificateFile /var/www/ssl/public.pem SSLCertificateKeyFile /var/www/ssl/private.key SSLCertificateChainFile /var/www/ssl/chain.pem &lt;/VirtualHost&gt; 三.防火墙配置： firewall-cmd –query-service https ##查看http服务是否支持，返回yes或者no firewall-cmd –add-service=https ##临时开放https服务 firewall-cmd –add-service=https –permanent ##永久开放https服务 然后重启防火墙即可 ","link":"https://kafuuneko.me/post/gEoKvnpp0/"},{"title":"IEEE标准","content":" IEEE标准 电气和电子工程师协会（IEEE）定义的单精度和双精度存储浮点数的标准如下图所示 单精度占用32位，双精度占用64位。单精度和双精度符号都只占用1位（0为正，1为负）。单精度指数占用8位，使用偏移量127，位数占用23位。双精度指数占用11位，使用偏移量1023，尾数占用52位。 规范化 为了使表示法固定部分统一，科学计数法（用于十进制）和浮点数表示法（用于二进制）都在小数点左边使用了唯一非零数码，这称为规范化。十进制系统中的数码可能是1~9，而二进制系统中该数码是1。 符号、指数和尾数 在应该二进制数规范化后，我们只存储了一个数的三部分信息：符号、指数和尾数。 符号 一个数的符号可以用一个二进制位来存储，0为正1为负。 指数 指数（2的次幂）定义为小数点移动的位数。小数点向左移为正向右移为负。 因为指数是有符号的数，尽管这可以用二进制补码来存储，但被一种称为余码系统的表示法取而代之。在该余码系统中，正的和负的整数可以作为无符号存储。为了表示正的或负的整数，一个偏移量加到每个数字中，将他妈统一移到非负的一边。这个偏移量的值是2^(m-1)，m是内存单元存储指数的大小。 尾数 尾数是小数点右边的二进制数。它定义了该数的精度。尾数是作为无符号整数存储的。但它不是整数，而是像整数那样存储小数部分。因为在尾数中，如果在数字左边插入多余的0，这个值会改变，而在一个真正的整数中，如果在数字左边插入多余的0，这个值不会改变。 IEEE标准浮点数转二进制 在S中存储符号（0或1） 将数字转换为二进制 规范化 找到E和M的值 连接S、E和M 例1：将3.6875转为二进制（单精度） 符号为正：S=0 十进制转换为二进制：3.6875=0b11.1011 直接将整数部分转换为二进制（无符号）：3 == 0b11 计算小数部分二进制 取小数部分乘2得到积，将积整数部分取出。接着继续用2乘以剩下的小数部分，直到积的小数部分为0，或达到精度限制。下例： 取3.6875的小数部分：0.6875 计算 积的整数部分 (0.6875 * 2) = 1.375 1 (0.375 * 2) = 0.75 0 (0.75 * 2) = 1.5 1 (0.5 * 2) = 1.0 1 小数部分为0，计算结束。 将积的整数部分按计算顺序排序即可得到小数部分的二进制：1011 规范化：0b11.1011 = (0b1.11011) * (2^1) 将0b11.1011的小数向左移1位，即得到0b1.11011。指数则为移动的位数（左移为正右移为负），在本例中的指数为1。规范化结果：(0b1.11011) * (2^1) 找到E和M的值 E = 规范化指数 + 偏移量 = 1 + 127 = 128 = 0b10000000 M = 规范化后的小数部分 = 0b11011(在后面补上23-5个0) 连接S、E、M S = 0b0，E = 0b10000000，M = 0b11011000000000000000000 R = S E M = 0b0 10000000 11011000000000000000000 例2：将-0.0234375转为二进制（单精度） 符号为负：S=1 十进制转二进制：0.0234375 = 0.0000011 直接将整数部分转换为二进制（无符号）：0 == 0b0 计算小数部分二进制 取0.0234375小数部分：0.0234375 (0.0234375 * 2) = 0.046875 0 (0.046875 * 2) = 0.09375 0 (0.09375 * 2) = 0.1875 0 (0.1875 * 2) = 0.375 0 (0.375 * 2) = 0.75 0 (0.75 * 2) = 1.5 1 (0.5 * 2) = 1.0 1 小数部分为0，计算结束。 将积的整数部分按计算顺序排序即可得到小数部分的二进制：0000011 规范化：0b0.0000011 = (0b1.1) * (2^-6) 将0b0.0000011的小数向右移6位，即得到0b1.1。指数则为移动的位数（左移为正右移为负），在本例中的指数为-6。规范化结果：(0b1.1) * (2^-6) 找到E和M的值 E = 规范化指数 + 偏移量 = -6 + 127 = 121 = 0b1111001 M = 规范化后的小数部分 = 0b1(在后面补上23-1个0) 连接S、E、M S = 0b1，E = 0b1111001，M = 0b10000000000000000000000 R = S E M = 0b1 1111001 10000000000000000000000 IEEE标准浮点数的数字还原 找到S、E和M的值 如果S=0，将符号设为正号，否者设为负号 找到位移量（E-偏移量） 对尾数去规范化 将去规范化对数字变为二进制以求出绝对值 加上符号 例：位模式（0b01000000011011000000000000000000） 首位表示S，后8位表示E，剩下23位是M S = 0b0 E = 0b10000000 M = 0b11011000000000000000000 符号设为正号 位移量= E-127 = 0b10000000-127 = 128-127 = 1 将0b1.11011去规范化：0b1.11011 * (2^位移量) = 0b1.11011 * (2^1) 二进制数是：0b11.1011 绝对值是：3.6875 计算整数部分：0b11 = 3 计算小数部分：0.6875 0b11.1011小数部分：1011 1 0 1 1 (1 * 2^-1) + (0 * 2^-2) + (1 * 2^-3) + (1 * 2^-4) = 1*0.5 + 0*0.25 + 1*0.125 + 1*0.0625 = 0.6875 整数部分+小数部分：3.6875 加上符号：3.6875 存储零 带有整数部分和小数部分对实数设置为0的时候数0.0，无法用以上讨论的步骤存储。为了这个特例，约定在这种情况下符号、指数和尾数都设为0 参考资料：《计算机科学导论》 ","link":"https://kafuuneko.me/post/38_5q2-N0/"},{"title":"我的世界服务器与插件开发相关链接","content":"文档 https://hub.spigotmc.org/javadocs/bukkit/overview-summary.html 中文文档以及中文文档源码 https://bukkit.windit.net/javadoc/ https://github.com/BukkitAPI-Translation-Group/Chinese_BukkitAPI Paper https://yivesmirror.com/downloads/paper ","link":"https://kafuuneko.me/post/t2U6P6fsi/"},{"title":"关于CakeGame的一些使用技巧","content":"实际命中率 = 自身命中÷（自身命中+对手闪避) 物品编辑右击物品可编辑物品介绍或删除物品 在编辑任务完成物品条件，技能消耗物品时，勾选物品代表则消耗物品 图片绘制文字大小适宜范围是12-24 编辑&gt;条件删除&gt;不填写条件直接删除则为清空玩家数据 关闭编辑器时如果出现解锁失败可直接强制关闭 打开编辑器后如果出现无法使用插件的情况可在设置中关闭数据库保护 职业属性可使用小数，计算使用四舍五入法 编辑器内的属性会随着等级自动重新计算直接修改无效 使用过一次技能书的技能才能在技能中显示 修改地图位置前请先备份数据库，尤其是在有玩家进行游戏的情况下修改 进入地图勾选上隐藏的地图后只能通过上下左右的通道进入无法直接传送 在编辑技能消耗物品时同任务相同勾选后为消耗相应物品，反之则只需要持有 地图中出现与消失为怪物出现时间，尽量不要用整数时间 地图中的刷新时间为该怪物被屠杀灭绝后的刷新时间不是单只刷新时间 地图中的进攻数量为几到几的随机数，如1-3为1到3只 物品编辑中的提升类药剂时效写0为永久提升，且时效为秒制 技能编辑中的冷却时间为秒制 物品编辑中物品被锁定后会变为无法交易无法丢弃的重要物品 特殊属性编辑，攻击中的吸血回复为百分比制，10%为造成10%的吸血 特殊属性编辑，攻击中的魔法穿透、物理穿透为百分比制，40%为忽视对方40%的物防/法防 特殊属性编辑，被攻击中的伤害免疫、伤害反弹均为百分比制，40%为免疫40%或反弹40%伤害，且反弹可以反弹两倍伤害，只需200 特殊属性编辑，被攻击中的反制打断是打断敌人的进攻，打断提示可双击编辑 特殊属性编辑，被攻击中的致命免疫为受到致死性伤害时免疫这次伤害，免疫提示可双击编辑 职业编辑中的初始职业无法删除的情况下可以新建一个职业，然后打开游戏设置的转职设置修改默认职业后再删除 游戏设置中的虚弱时间为分钟制，昵称长度为字节制一个字等于2个字节 游戏设置中的PVP/PVE中可以打开浮动伤害并且修改暴击倍率 游戏设置中的功能指令修改后需要重启酷Q或刷新游戏数据才能使用新的触发命令，关键词敏感关闭后可以减少正常聊天的影响 技能名称以 ~. 开头可以让用户看不到这个技能，但不影响使用 执行 DELETE FROM Global WHERE ID=’636C6F636B’ AND SECTION=’72616E6B696E672E6C6173742E74696D65′ 可以重置排行榜刷新时间 ","link":"https://kafuuneko.me/post/D1qG-jv4O/"},{"title":"Android SQLite编辑器","content":"SQLite编辑器安卓版 支持表格查询与编辑，视图查询，执行SQL等基本操作 项目仓库：https://github.com/KafuuNeko/SQLiteEditor ","link":"https://kafuuneko.me/post/pel2mo5Kn/"},{"title":"树莓派安装使用BOINC","content":"一.安装BOINC 更新APT sudo apt-get update 安装boinc客户端 sudo apt-get install boinc-client 二.基础使用 在安装好boinc客户端后，点击树莓派左上角，在System Tools中打开BOINC Manger 在View里点击Advanced View使用高级界面（操作更舒服一些） 不熟悉英文的可以在 Options -&gt; Other options里修改语言为中文简体 然后重启软件（关闭软件窗口后如果任务栏还存在Boinc，需要右击，点击Close Window），即可显示为中文 三.添加项目 可以通过 工具(Tools)-&gt;增加项目(Add Project) 来添加新项目 选中您感兴趣的项目，访问项目网址，注册您的账号。 注册完成后点击下一步，选择 是的，我已经注册过了 输入您刚刚注册的电子邮件与密码，点击下一步，即可加入此项目 ","link":"https://kafuuneko.me/post/pu8WXV_ys/"},{"title":"CakeGame","content":"点击下载 所有压缩包的秘密都是：dmmy123. 整理了机器人游戏框架-CakeGame历代版本，有需要的小可爱可以到这下载~~ PS:请不要使用高版本的CakeGame后换回低版CakeGame! ","link":"https://kafuuneko.me/post/N2ehinTyr/"},{"title":"基于Java开发的Bilibili直播间弹幕监测","content":"本项目可实时监测Bilibili指定直播间弹幕信息 https://github.com/KafuuNeko/Bilibili_LiveBroadcast ","link":"https://kafuuneko.me/post/2dpRNz_9Y/"},{"title":"解决LockTableView.setTableDatas()后可能出现列宽不对齐的现象","content":"解决方法： private List mHeadViews = new ArrayList&lt;&gt;(); 在调用createHeadView的时候向mHeadViews保存第一行所有列视图 在initData中，动态调整mHeadViews中每一个视图的宽度 for (int i = 0;i &lt; mHeadViews.size();i++) { ViewGroup.LayoutParams params = mHeadViews.get(i).getLayoutParams(); if (isLockFristColumn) { params.width = DisplayUtil.dip2px(mContext, mColumnMaxWidths.get(i + 1)); }else { params.width = DisplayUtil.dip2px(mContext, mColumnMaxWidths.get(i)); } mHeadViews.get(i).setLayoutParams(params); } ","link":"https://kafuuneko.me/post/xniZk4LLU/"},{"title":"数论：幂乘","content":" 求x的幂乘可以利用x^n = (x ^ 2) ^ (n / 2)的性质，用反复平方法快速求出 ： pow(x, n) 1 (n=0时) pow(x * x, n / 2) (n为偶数时) pow(x * x, n / 2) * x (n为奇数时) 例如：2^11展开如下所示： 2^11 = ((2 * 2) ^ 5) * 2 4^5 = ((4 * 4) ^ 2) * 4 8^2 = (8 * 8) ^ 2 16^2 = (16 * 16) ^ 1 256^1 = ((256 * 256) ^ 0) * 256 65536^0 = 1 递归反复平方法 pow(x, n) if(n == 0) return 1; if((n &amp; 1) == 0) return pow(x * x, n / 2); else return pow(x * x, n / 2) * x; //C++实现 constexpr double mypow(double x, uint32_t n) noexcept { return (n == 0) ? 1 : ((n &amp; 1) == 0) ? pow(x * x, n / 2) : (pow(x * x, n / 2) * x); } ","link":"https://kafuuneko.me/post/zMwuVDvrc/"},{"title":"二维矩阵和","content":"二维前缀和，前缀和即当前元素与之前的元素之和，例如现有一个3行4列的矩阵 定义：本例中x和y从1开始，例如：(1, 1)的值为6，(2, 1)的值为7 (1, 1)的前缀和即1 + 2 + 5 + 6 = 14 依次计算(0, 0)、(0, 1)、(1, 0)的前缀和 (0, 0) (0, 1) (1, 0) 根据上面的结果，计算(1, 1)的前缀和 (0, 1)的前缀和的值为3（红色矩形中的值相加） (1, 0)的前缀和的值为6（蓝色矩形中的值相加） 计算(1，1)前缀和的值只需将红色矩形(0, 1)的前缀和值加上蓝色矩形(1, 0)的前缀和值，然后减去这两个矩形重叠的部分的前缀和的值（因为(0, 1)和(1, 0)的前缀和的包含了(0, 0)，也就是(0, 0)的前缀和值被多加了一遍，所以需要减去），再加上(1，1)处的值即可计算出(1, 1)的前缀和值 3(红色矩形) + 6(蓝色矩形) - 1(重叠的部分) + 6(自身的值) = 14 所以可以得出递推公式：DP(x, y) = DP(x - 1, y) + DP(x, y - 1) - DP(x - 1, y - 1) + M(x, y) #include &lt;iostream&gt; int M, N; int Martix[101][101]; int DP[101][101]; int main() { std::cin &gt;&gt; M &gt;&gt; N; for (int i = 1; i &lt;= M; ++i) { for (int j = 1; j &lt;= N; ++j) { std::cin &gt;&gt; Martix[i][j]; } } for (int i = 1; i &lt;= M; ++i) { for (int j = 1; j &lt;= N; ++j) { DP[i][j] = DP[i - 1][j] + DP[i][j - 1] - DP[i - 1][j - 1] + Martix[i][j]; } } printf(&quot;前缀和：\\n&quot;); for (int i = 1; i &lt;= M; ++i) { for (int j = 1; j &lt;= N; ++j) { printf(&quot;%d &quot;, DP[i][j]); } printf(&quot;\\n&quot;); } return 0; } /* input: 3 4 1 2 3 4 5 6 7 8 9 10 11 12 output: 1 3 6 10 6 14 24 36 15 33 54 78 */ ","link":"https://kafuuneko.me/post/PV0gz9fjP/"},{"title":"KMP算法","content":"Knuth-Morris-Pratt算法（简称KMP），是一种高效的字符串匹配算法 相较于暴力匹配O(mn)的时间复杂度，KMP的算法时间复杂度为O(m+n)，性能上有极大的提升，KMP算法极大的减少了不必要的回溯过程。 假定搜寻的文本串下标索引是i，模式串下标索引是j，KMP算法在匹配过程中，文本串下标i会一直递增，直到结束，不会回退。 一.NEXT数组应用 NEXT数组是KMP算法的核心，它指向当文本与模式串失配时模式串将要回退到的位置。 假定模式字符串为 aabaab，那么这个模式串的NEXT是(暂且不管怎么获得的){-1,0,1,0,1,2} 当模式串在第0位发生失配，文本指针i向后移动一位 当模式串在第1位发生失配，模式串指针回退到第0位 当模式串在第2位发生失配，模式串指针回退到第1位 当模式串在第3位发生失配，模式串指针回退到第0位 当模式串在第4位发生失配，模式串指针回退到第1位 当模式串在第5位发生失配，模式串指针回退到第2位 例：寻找字符串‘aababaabaaba’中’aabaab’首次出现的起始位置，那么匹配过程是这样的： 当模式串在第4位发生失配，模式串指针回退到第1位 当模式串在第1位发生失配，模式串指针回退到第0位 当模式串在第0位发生失配，文本指针i向后移动一位 匹配完成，获取’aabaab’首次出现的起始位置为5 二.制取NEXT数组 重新观察一下模式串’aabaab’的NEXT数组 当j=5的位置发生失配时，next数组指示模式串指针j回退到2位置 观察j=5位置，可以发现 substr[j-1] = substr[next[j-1]] =&gt; substr[4] = substr[next[4]] =&gt; substr[4] = substr[1] substr[j-2] = substr[next[j-2]] =&gt; substr[3] = substr[next[3]] =&gt; substr[3] = substr[0] 也就是说 j = 5的前两个元素与next[5]所指向的2的前两个元素相等 正因为这样，在j=5位置发生失配时，j指针才能直接回退到2 例如用这个模式串去搜索aabaacaabaab 在j=5的位置发生失配，j指针回退到2 回退后我们可以保证模式串j=0,j=1位置的字符必定与文本i=3,i=4位置的字符相等，所以只需判断移动后模式串j位置的字符与文本i位置的字符是否相等即可 我们取得‘aabaab’的所有前缀，无视每个前缀的最后一个元素，每个前缀除去最后一个元素，后缀与前缀的重叠次数就是next的值，第一个next值固定为-1，第二个next值固定为0 S NEXT a -1（固定） aa 0（固定） aab 1（aa的前后缀有 a、a）（相同的有一个） aaba 0（aab的前后缀有a、aa、b、ab）（没有相同的） aabaa 1（aaba的前后缀有a、aa、aab、a、ba、aba）（相同的有一个） aabaab 2（aabaa的前后缀有a、aa、aab、aaba、a、aa、baa、abaa）（相同的有两个） 这样，我们就求得了NEXT数组={-1, 0, 1, 0, 1, 2} 再次观察 可知，如果我们想知道next[j+1]的值，只需判断T[j]是否等于T[ next[j] ] 1.我们可以定义一个临时变量：k = next[j] 2.如果k = -1，那么next[j + 1] = 0，否则继续步骤3 3.如果T[j] == T[k]，那么next[j+1] = k + 1，否则继续步骤4 4.如果T[j] != T[k]，那么k=next[k]，重复判断步骤2 例：J表示模式串索引，T表示模式串数组，N表示模式串NEXT数组 一、j = 2, N[j]=？ 假定 k = N[j – 1] = N[1] = 0 判断 T[j – 1] 是否等于 T[k]：T[j-1] = T[1] 是否等于 T[k] = T[0] T[1] = T[0] =&gt; ‘a’ 等于 ‘a’ 因为T[1] = T[0]，所以N[j] = k + 1 =&gt; N[2] = 1 二、j = 3, N[j]=？ 假定 k = N[j – 1] = N[2] = 1 判断 T[j – 1] 是否等于 T[k]：T[j-1] = T[2] 是否等于 T[k] = T[1] T[2] = T[1] =&gt; ‘b’ 不等于 ‘a’ 所以k = N[k] = N[1] = 0 再次判断 T[j – 1] 是否等于 T[k]，T[2] = T[0] =&gt; ‘b’ 不等于 ‘a’ 所以k = N[k] = N[0] = -1 因为k = -1，所以N[3] = 0 制取Next数组代码： size_t npos = static_cast&lt;size_t&gt;(-1); sizr_t* KMP_MakeNext(const char* substr, size_t len) { size_t* next = new size_t[len];//next数组是new的，没使用智能指针，所以用完注意释放 next[0] = npos; int j = 0; int k = npos; while(j &lt; len - 1) { if(k == npos || substr[j] == substr[k]) { ++j; if(k == npos) k = 0; else ++k; next[j] = k; } else { k = next[k]; } } return next; } 四.字符串匹配 既然已经获得了Next数组，那么字符串匹配就是一件小事了。 以下便是使用NEXT进行字符串匹配的代码 size_t KMP_Find_Count(const char* findstr, const char* substr) { size_t find_len = strlen(findstr), subs_len = strlen(substr); if(subs_len == 0 || find_len &lt; subs_len) return 0; size_t* next = KMP_MakeNext(substr, subs_len, false); size_t count = 0; size_t j = 0, k = 0; while( j &lt; find_len ) { if(k == npos || findstr[j] == substr[k]) { //指示后移，或匹配成功 ++j; if(k == npos) { k = 0; } else { ++k; } if(k == subs_len) { //子串匹配成功，计数+1，并回溯到匹配成功的位置，继续匹配 ++count; k = next[k - 1]; --j; } } else { k = next[k]; } } delete[] next; return count; } ","link":"https://kafuuneko.me/post/kGEMmaOzR/"},{"title":"PCQQ8.6协议分析","content":"最初发布地址：https://www.52pojie.cn/thread-825868-1-1.html 进程：6880,QQ:..........,版本:QQ8.6 ecdhkey:03 42 D9 64 FC 18 11 6F 34 44 68 57 C0 18 B9 8F 65 93 49 AF 05 92 D4 04 C2 decodekey:C7 17 C9 B0 6F 88 B9 B5 A7 2A 64 64 69 1B 42 40 0825Data0:00 18 00 16 00 01 0825Data2:00 00 04 53 00 00 00 01 00 00 15 79 0825令牌：CD 76 D3 81 A7 37 6A A6 DB 02 A8 F6 9B 86 EC 54 95 EA DB 97 14 6E 28 8C 34 FF 08 A9 11 B3 E1 6E B1 55 A0 60 F4 35 E3 00 91 E6 02 8C 32 84 9B 1D E8 D1 5F EC 85 D1 DC F7 publickey：03 42 D9 64 FC 18 11 6F 34 44 68 57 C0 18 B9 8F 65 93 49 AF 05 92 D4 04 C2 0836Fix：31 27 D7 14 2F 93 7E 10 6F 2A 51 29 AC 54 50 29 0826Key2：10 01 02 00 62 00 01 AF 86 DD F6 43 C1 88 1D 8C E9 45 89 A8 B6 BD C6 0836令牌：42 36 94 7B B6 65 A8 9C 75 FD 98 E0 AC 8F 84 76 20 D3 14 F4 5C 3D BC 90 0F D0 3E 92 B0 37 70 09 63 12 3F BD 20 8E F4 66 12 38 B6 1B 3D 13 50 0D 64 E7 35 75 2A DD C1 CB MD51:46 65 AF 69 21 98 9E C9 0B AC 9D 5C 8D 4D 9F 42 MD52(密码和账户生成的)：E1 C6 0F FB B1 EF 96 AE 0E FF 08 0E FD A1 67 B7 tgtgkwy：8D 19 AE A0 07 7E 8E 8F D8 BA 61 F9 23 01 56 66 0825发送包 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 02 包头 36 61 版本 08 25 指令 7A 4D 标识 6A 4E AC D5 QQ [url=tel:03 00 00 00 01 01 01]03 00 00 00 01 01 01[/url] 00 00 67 FD [url=tel:00 00 00 00]00 00 00 00[/url] 固定 [url=tel:49 59 86 94 95 42]49 59 86 94 95 42[/url] 9F 0C 26 EC CF 36 BE 1B 96 1E 密匙 F0 6A B7 2E 15 12 下列全是密文 2D 6C E1 2D ED 19 37 FE 3F [url=tel:00 27 72 35]00 27 72 35[/url] 3E 28 9E 0E 64 B2 1B F6 76 25 14 DB F7 92 ED 68 89 1F 36 F4 BC CD D7 ED DB AE 03 F6 FC 85 0F 5F 6D C9 66 35 74 C6 3A 83 29 89 D6 86 79 9B 66 E5 41 22 DC 3B 24 FA 84 59 85 0F [url=tel:28 26 01 71 68 48 66]28 26 01 71 68 48 66[/url] 8C EF 35 9E 23 63 E8 8D 31 71 D9 [url=tel:14 40 52 94]14 40 52 94[/url] A0 1E 20 31 58 16 C8 4A 52 E4 79 A3 29 03 包尾 0825接收包 02 36 61 08 25 7A 4D 和之前一样 6A 4E AC D5 QQ 00 00 00 固定 0D 49 99 4E 8F 0B E3 B1 5A C0 5C 87 9C C9 9E 50 CF ED 9B 61 8F 88 BA C6 6F AF 5A E5 1B 8E 20 A6 2D 10 B7 58 23 52 32 AA CD FF 0A ** ** 85 D2 B4 C4 BB F1 AE 40 11 D3 97 5E 17 0E 5A D8 D7 8F E5 44 9A 04 A1 EA ** ** ** ** ** 97 0D E2 BF 9F 9E 1D BA 9D 91 70 96 D1 B5 08 10 C1 C5 25 60 91 C4 51 B0 1E 19 13 6C C0 21 全是加密数据（为了我自己的隐私，部分内容*） 03 包尾 加密数据解密结果： 00 01 12 00 38 CD 76 D3 81 A7 37 6A A6 DB 02 A8 F6 9B 86 EC 54 95 EA DB 97 14 6E 28 8C 34FF 08 A9 11 B3 E1 6E B1 55 A0 60 F4 35 E3 00 91 E6 02 8C 32 84 9B 1D E8 D1 5FEC 85 D1 DC F7 0825Tokn 00 17 00 0E 00 01 5B F2 C5 E4 登录时间 ** ** ** ** 登录IP C4 DF 00 00 03 10 00 04 78 CC 11 7C 0836发送包 02 36 61 08 36 66 77 数据包标识 6A 4E AC D5 QQ 03 00 00 00 01 01 01 00 00 67 FD00 00 00 00 00 01 01 02 定义fix1 00 19 publickey长度 03 42 D9 64 FC 18 11 6F 34 44 6857 C0 18 B9 8F 65 93 49 AF 05 92 D4 04 C2 publickey 00 00 00 10 8F 4E 4E 48 5B 4C 6B E7 DA 00 02 4F 5C 86 88 AD 0836Key1 C1 03 76 下列全为加密数据 5C FA 24 31 A0 36 27 9C 78 D7 DF 61 D3 FB 00 48 C5 1C 8A 09 B9 6F 20 00 35 D6 42 59 0F 12 08 FB EB 74 08 89 91 62 40 DE 05 A7 DA 9E FF 35 7C 41 F6 4C A7 2D 89 80 BD 4A 23 0D 83 56 DE 05 87 9B 75 4E B5 36 73 43 78 31 0C 44 09 60 DC 34 B8 D7 E5 7C 34 52 EE 07 C1 C1 FD 9D AE DD 93 1C 5A F8 87 53 C1 15 F0 02 A6 7C 54 E4 4E 37 27 54 B6 E4 85 2C 5A 54 BC B5 7E 8B 83 70 B1 08 CC A4 37 A8 11 41 6F 17 F6 AF C8 B8 5A F9 EF 04 E0 D1 A7 DD 84 20 8F F1 11 B4 69 98 DE 0D CF DC 41 EC D5 6F CB 76 AD E8 7F 30 88 C5 9A 3C E5 2F CC 40 DF 37 F2 09 6E 96 A4 61 96 A8 4F 46 67 31 03 22 50 B2 1E 65 6F 0C AB 87 BE 3F 24 9C 00 37 64 75 17 95 12 55 50 A5 FD 8B 5D DE 66 E5 C9 42 D5 61 8E 31 1A 50 B6 E6 20 0B C3 B9 DC D1 3E 5C B3 73 39 70 83 8F 8C 9E 1A 37 FA 69 81 41 98 F5 CA 6A B0 B0 47 87 D0 D1 CD D4 B0 72 5B 25 29 42 66 A0 8D 9C 8F 78 F6 56 67 FD D1 48 F1 39 71 31 E6 F7 80 DD 7E 36 16 72 5B 09 29 33 65 9C 7A 96 56 9A 59 9E 2E 7B ED 37 E9 5B F2 F9 D6 C6 BC EB A4 AC 51 13 58 E0 67 6A 06 BC 27 DE 22 B1 90 23 50 9E 3F F0 56 61 A0 C5 6F 46 5F B8 DA C1 63 C4 61 F9 C2 EA 16 F7 44 4E 6F 82 D5 6B 78 2C 1B 35 D9 63 55 3E 8D 3A 9F C4 3E D6 B9 23 6E 1F ED 4E 70 91 E5 3B 5F CB 30 06 A7 7A E1 64 DA 25 07 EE 9F 80 19 E9 96 4D 4F A2 58 6C 65 10 A1 F1 DE 54 80 F7 65 98 E7 F2 EF 4C D7 8C C2 39 BA 0A 97 40 52 4F F9 B0 46 3B E4 90 23 CD 9E B1 39 AD 6F 5B 98 7E AD 55 22 6E D3 CD 61 B2 31 09 47 53 C5 9C A7 8E 39 34 44 12 9C 44 B1 F0 D2 42 51 E0 3D 21 0B B2 8E A4 EC 3F 24 AE E2 A8 3B EC E9 EF 15 59 03 F0 8E B9 C9 14 07 32 10 88 75 16 65 A5 FF C9 73 92 D8 5F 94 1C D5 1F 16 CE 89 4E 52 E8 62 50 10 EB 82 55 51 8E B4 5A 2F 79 7C 53 BC C0 DE 9A D2 6B 0A D7 1A B7 F6 4E 04 63 E6 93 CB 6B 68 92 9A 03 加密数据解密结果： 01 12 00 38 固定 CD 76 D3 81 A7 37 6A A6 DB 02 A8 F6 9B 86 EC 54 95 EA DB 97 14 6E 28 8C 34 FF 08 A9 11 B3 E1 6E B1 55 A0 60 F4 35 E3 00 91 E6 02 8C 32 84 9B 1D E8 D1 5F EC 85 D1 DC F7 0826令牌 03 0F TLV_030F 00 0C 设备名长度+2 00 0A 设备名长度 4D 41 43 42 4F 4F 4B 50 52 4F 设备名 00 05 00 06 00 02 6A 4E AC D5 QQ 00 06 00 78 二次加密数据长度 AA D8 A8 B9 37 8E 2F 4E A4 63 91 E3 71 EA 62 F8 72 6E E8 B6 1E E8 58 A3 CE 98 C6 0C 74 18 89 4C 83 EE BE AE 20 1B CE CB 80 C0 63 8F A8 C2 FA BE 8E 19 53 25 9E 02 0D 26 D5 48 F3 65 94 E4 E3 C1 F2 27 20 03 7E 18 C8 4D 4C FD F8 D4 33 54 8E D3 42 22 67 F8 5F A2 D5 E1 B3 27 4A 3F 65 A5 2C 95 C4 39 9F 65 5E B7 20 1E 3B 48 30 4B 76 C8 63 EF 3A 88 3B 78 E9 A9 67 B8 二次加密数据长度到这全是加密的数据 01 02 03 04 05 06 07 08 09 10 11 12 13 使用MD52解密 key：E1 C6 0F FB B1 EF 96 AE 0E FF 08 0E FD A1 67 B7： 56 8A E7 92 随机 00 02 6A 4E AC D5 QQ [url=tel:00 00 04 53 00 00 00]00 00 04 53 00 00 00[/url] [url=tel:01 00 00 15 85]01 00 00 15 85[/url] 2825Data2 00 00 01 46 65 AF 69 21 98 9E C9 0B AC 9D 5C 8D 4D 9F 42 MD51 5B F2 BF 72 登录时间 [url=tel:00 00 00 00 00 00 00]00 00 00 00 00 00 00[/url] [url=tel:00 00 00 00 00 00]00 00 00 00 00 00[/url] [url=tel:70 31 77 12]70 31 77 12[/url] 登录IP [url=tel:00 00 00 00 00 00 00]00 00 00 00 00 00 00[/url] 14 00 10 31 27 D7 14 2F 93 7E 10 6F 2A 51 29 AC 54 50 29 0826Fix1 8D 19 AE 00 15 00 30 00 01 01 0E 1C D5 DB 00 10 04 F1 4A AD 00 00 00 00 00 00 00 00 00 00 00 0002 86 10 6F DD 00 10 31 27 D7 14 2F 93 7E 10 6F 2A 51 29 AC 54 50 29 0836Fix 00 1A 00 40 固定 B2 02 AA B6 9B 23 62 8F 74 B9 8F 23 BC 33 E5 EC 03 20 2A AA EF 2B 03 F8 2D 63 27 0A D0 37 C1 A5 F6 97 D3 D5 E8 5E 26 0F 12 26 45 4E 18 CF 39 CC 99 6D FF 9F A4 4F D0 5A F0 BE 1C 7F FF C1 3F BC 加密的内容 1 2 解密结果为：[url=tel:00 15 00 30 00 01 01]00 15 00 30 00 01 01[/url] 0E 1C D5 DB 00 10 04 F1 4A AD [url=tel:00 00 00 00 00 00 00]00 00 00 00 00 00 00[/url] [url=tel:00 00 00 00 00 02 86]00 00 00 00 00 02 86[/url] 10 6F DD [url=tel:00 10 31 27]00 10 31 27[/url] D7 14 2F 93 7E 10 6F 2A 51 29 AC 54 50 2 其中：31 27 D7 14 2F 93 7E 10 6F 2A 51 29 AC 54 50 2为之前定义的0836Fix，使用tgtgkey解密 00 18 00 16 00 01 0825Data0 00 00 04 53 00 00 00 01 00 00 15 79 0825Data2 6A 4E AC D5 QQ 00 01 00 00 01 03 00 14 00 01 00 10 97 25 CE F1 4D 99 CD 67 C9 58 BE DB 5F 06 64 53 05 07 00 11 01 97 23 B9 72 5C 59 AA 23 51 AB E5 0A 35 8A 4D 3B 以上数据全部定义为Fix3 03 12 00 05 01 00 00 00 01 05 08 00 05 01 00 00 00 00 03 13 00 19 01 01 02 00 10 7D 7B EF 63 A2 63 09 46 26 09 1D ED 8E 89 BD 47 00 00 00 Fix3到此全部定义为Fix 10 01 02 00 62 00 01 AF 86 DD F6 43 C1 88 1D 8C E9 45 89 A8 B6 BD C6 0826Key2 00 38 固定 42 36 94 7B B6 65 A8 9C 0836Token 75 FD 98 E0 AC 8F 84 76 20 D3 14 F4 5C 3D BC 90 0F D0 3E 92 B0 37 70 09 63 12 3F BD 20 8E F4 66 12 38 B6 1B 3D 13 50 0D 64 E7 35 75 2A DD C1 CB ---- 00 14 8E C5 CC 09 FA 66 21 0A 32 91 A7 6C 36 B8 35 94 crc32Data 43 51 2D F6 crc32Code 0836接收包 02 包头 36 61 版本 08 36 指令 66 77 标识 6A 4E AC D5 QQ 00 00 00 固定 7C 99 红字为加密内容，使用decodekey可以完成第一次解密 EA 0F 67 4D F5 7E E9 94 34 9C B4 68 54 77 56 92 5D D1 AA 2C 94 32 12 4C 2B FB E4 8C 5A 78 CF 3D 93 2C B1 7B B2 7C 36 AB E6 68 3A 6F 42 A2 61 97 7A 08 7A 12 F9 3A DC E1 9E 2B 3B 75 0F 76 18 8D 4A 23 67 42 C4 75 67 D1 1A 78 4C A1 CB ED 40 FD CF 40 62 C8 C8 6E 01 E5 E3 51 49 B2 34 2E 51 BB 9F A1 25 EC 11 20 6F A7 16 C7 57 26 D8 A7 81 54 05 D0 E7 2A C4 EF FB AD 4E 67 FA CC BB 18 D6 00 E3 16 35 5B 0F 29 7B F3 EC 15 0E 80 30 BB 18 41 61 BC 9E A7 69 5E 24 FC 34 2D 74 10 47 73 B2 2C CF 98 5A 49 69 71 F0 2E 6A BF 48 90 D3 1B AE FE 68 9B A4 E2 BC B8 2C 91 8C 96 1D CE AE D2 DA 27 60 CB 5B 13 79 39 80 55 6A 96 0F E2 A0 D7 89 31 43 1B 87 F1 5F 67 DD 4D 0B B5 80 6C FE 3E 52 06 DC 3B 98 C1 3F F8 34 AC 21 46 32 E7 6C C0 74 D1 F4 2A 5F 26 FF 39 9C C4 74 7F B3 79 95 D7 03 红字第一次解密结果如下： CE 0E 0D 26 99 11 75 CE 3E D1 B0 AE 14 77 3E 71 27 53 DC 93 DA A8 F0 8A E9 2F E9 52 7A 12 6A 51 EE 24 E8 5A ED 86 86 48 A0 ED 8A DD 78 55 36 86 18 57 0B C0 F9 ED 4A 14 63 5B A0 4B DC BE 66 58 B4 C9 8B E2 3D 84 B0 B6 0E 92 DC 8F A5 BA BF F9 7A 8D 81 27 63 07 FC 34 A3 A3 BB 51 1B E9 7A 0E E1 41 94 73 66 AD FF 8E 9A C9 E5 82 6E 7E E4 55 71 F5 20 8D B7 9B 84 C1 FF CB 75 37 E1 66 21 E1 EF BF 6B 23 A6 08 82 55 B5 2B DB 4A C6 0C 00 73 C0 B5 60 66 64 66 AA 2C 65 95 17 3B 5C DB 5A 3E 78 EE 40 C6 85 57 CE 01 2B 7D CD 73 A3 F2 1C 9C B6 3C BF 43 DD B8 88 28 CD CE DC CE 22 AB 31 21 AE 56 8D 55 AB A6 0D 17 9E AF B8 DC 87 8A 0B DE 19 C5 71 82 42 BC F9 41 35 7A 04 75 EA 6A C2 35 A3 B3 64 1C 0C 46 DD 5E 5F F2 33 CE EA 27 08 8B 接着可以使用tgtgkey进行第二次解密： 01 00 1E 00 10 41 2E 51 2A 69 7A 21 47 65 3F 7D 5F 7A 50 62 79 更新tgtgkey 00 06 00 78 19 96 7D 84 64 37 0F (K001)这些红字为密匙，可使用MD52进行解密 93 23 CA 00 B6 B8 70 30 D2 AD 9D 7B FB 96 51 29 86 05 DA 5F 3D 02 5C E7 A5 8B B6 AD 72 5D 61 06 F3 CA C8 98 09 BC A3 E3 95 04 B4 FF F2 E1 C0 01 AC D3 C1 8B 0E 07 77 AD 0C 0A 03 C2 FD 25 CC F5 5A FD 84 94 C9 DC 47 88 80 28 B0 04 72 72 87 82 4E 68 B4 7E 95 A1 83 15 58 75 2A B1 CA 81 BE 75 B0 10 43 B3 DF 5C D6 E1 A2 78 E4 3D A3 90 08 F7 26 01 10 00 3C 00 01 00 38 B4 A7 CC 61 48 CB 10 这里的红字是令牌 22 CE AD 5A 8B 92 7C 64 14 40 B5 79 AA DB 60 A0 3F 8A DB 12 37 FB 31 9F C9 2E EB CD 69 93 8F 97 5C 93 22 2B CF BC 2D 73 25 7E 6E 4D 73 A0 C1 DD 66 01 15 00 10 86 8F 93 67 F9 85 FF 05 0C 91 33 8A 39 0C DB AA 0836二次发送包 02 36 61 08 36 66 78 数据标识 6A 4E AC D5 QQ 03 00 00 00 01 01 01 00 00 67 FD 00 00 00 00 00 01 01 02 定义fix1 00 19 03 42 D9 64 FC 18 11 6F 34 44 68 57 C0 18 B9 8F 65 93 49AF 05 92 D4 04 C2 publickey 00 00 00 10 49 C2 39 1D C7 37 4F BC 89 58 F8 E3 EF D6 AD 77 0836Key1 B5 3F EE 下列全为加密数据 A2 5D 31 ED 14 CE 8E 0B 25 F5 AB E7 43 8E 0F 9E F6 B2 84 1A 58 24 C8 57 D0 24 8E 9E 66 8B 33 EB E9 1C 6D 85 9D CE 12 4C D8 FE C9 BA 0E 70 CA 38 1B DC BB 35 DA 85 83 83 BC C2 4C EE 22 E8 14 A1 57 8B 24 9A D6 FB 23 F2 6F 26 91 9B 3D AC C7 2C FD 60 E5 C7 4C 52 C4 40 3D 5E 76 0A 16 CC F1 56 19 BA F3 A5 BA E9 49 8E 81 51 C2 B7 95 C4 21 B8 63 F4 85 65 D2 D7 A4 C5 A2 F0 07 0E 8F 4A 4A D7 8F C5 36 C3 AC 94 93 66 E9 82 B9 AF 91 8B EF D2 77 01 2C C4 23 63 66 4F 5A 7D DD 49 B2 B2 8C 57 5B 1C F0 87 6E C7 EA 6B 8A 29 60 BE 61 FE 9E BB AF 5D 6A 6B C1 25 7E BB AD 2D 5A 3D E0 2C 71 48 06 A2 56 2A A7 03 7B 3E 9A 4E 49 D1 1F 73 DA 15 45 96 6B 90 3E 83 86 DA 26 B6 39 84 FD 8E A2 50 98 0E 05 E8 4D 83 03 91 A3 18 92 7E 20 B2 18 96 E5 94 C4 B7 20 AA C8 83 72 3E 8A 5A BE D4 B9 7A FC 7B 30 59 13 7D 6A 39 49 3A 3A 46 7E 40 57 2C 76 01 73 3C AD 00 B2 50 53 E8 99 A3 47 8B 41 0D 42 BB DB 95 02 0C CC C1 B6 C2 EF F9 9F 6A 90 3A CB 66 6C 44 E3 69 E4 39 C9 AA 4A B9 8E 6E F2 33 B9 4A 7F 7C 5C 0A 2E 24 13 65 68 FF B3 68 71 C2 F6 B4 BA A6 F6 3A 1F 27 F8 DE 46 FC F4 19 5D D3 EA 39 71 3F 53 25 DB C1 9F CF D1 A2 CD 99 67 8E 51 15 B4 23 BD 86 DA AE C5 F8 BE 96 99 02 84 6C DF BD F9 A8 1E 01 9E A2 38 71 71 16 6E 53 F2 14 EA 35 9A CD 28 F4 A0 1E 79 78 11 0B 26 2F 34 43 44 7A 65 1D 66 A8 62 CB E5 92 76 C8 5B 48 4B B7 A4 33 CA D5 8C ED 4C 85 69 9A 84 5D 64 FF 59 F5 7B 3C 78 C5 70 9C 2A 7E 6F 20 5F 94 37 24 31 53 15 B7 D7 2C E8 E8 23 A8 30 73 1D A9 4F 65 D9 1D 96 BC 46 71 26 4D 2D 8B 12 BB 51 CA 55 89 28 21 7D 28 0B 4A D7 5C CB BA 14 94 9B AA 66 EF FA A0 57 D4 6E F1 81 95 E6 94 53 27 72 4F B3 90 C4 B3 33 94 D9 11 0A A0 75 0A 74 BF 29 9E D8 0B 5C 3B 58 B1 81 AD 78 98 E9 4C FE CC 22 9C E5 29 1F F4 7A FD 16 50 EF F1 8C 2E 92 7F AA AA 98 01 1B DE 6B 0D 6E 28 53 44 C3 95 9F EE CA EC 8A EC 3D 1A B5 72 5E 35 3E D6 5F 2D 6F ED E9 30 69 FA 58 A8 18 98 83 2F FF CB 42 13 39 67 B2 96 54 F0 36 D3 34 EF C7 72 7C 33 A0 F6 EC FC 9C 44 4D E1 05 EC 09 28 F0 42 29 0B 23 62 90 5F B1 86 9F 18 D2 C5 D7 C6 C2 F8 15 E7 34 9B F5 86 5F 3F C7 45 48 7E 62 6A AB 3B 4B 8A BE 4C C8 9C 7C B1 FC 5D 3F 2F 6D D8 4F 73 BD 21 09 2D 50 F9 68 05 FE EF 65 D6 81 30 49 88 DD 84 A7 52 25 2D 19 A8 8F 37 11 BE 41 0B CC 0C 56 03 包尾 解密后 01 12 00 38 CD 76 D3 81 A7 37 6A A6 DB 02 A8 F6 0825令牌 9B 86 EC 54 95 EA DB 97 14 6E 28 8C 34 FF 08 A9 11 B3 E1 6E B1 55 A0 60 F4 35 E3 00 91 E6 02 8C 32 84 9B 1D E8 D1 5F EC 85 D1 DC F7 --------- 03 0F 00 0C 00 0A 4D 41 43 42 4F 4F 4B 50 52 4F 以上全是设备信息 00 05 00 06 00 02 6A 4E AC D5 QQ 00 06 00 78 二次加密长度 19 96 7D 84 64 37 二次加密数据 0F 93 23 CA 00 B6 B8 70 30 D2 AD 9D 7B FB 96 51 29 86 05 DA 5F 3D 02 5C E7 A5 8B B6 AD 72 5D 61 06 F3 CA C8 98 09 BC A3 E3 95 04 B4 FF F2 E1 C0 01 AC D3 C1 8B 0E 07 77 AD 0C 0A 03 C2 FD 25 CC F5 5A FD 84 94 C9 DC 47 88 80 28 B0 04 72 72 87 82 4E 68 B4 7E 95 A1 83 15 58 75 2A B1 CA 81 BE 75 B0 10 43 B3 DF 5C D6 E1 A2 78 E4 3D A3 90 08 F7 26 加密数据到此为止 00 15 00 30 00 01 01 0E 1C D5 DB 00 10 04 fix2 then F1 4A AD 00 00 00 00 00 00 00 00 00 00 00 00 02 86 10 6FDD 00 10 31 27 D7 14 2F 93 7E 10 6F 2A 51 29 AC 54 50 29 fix2end 00 1A 00 40 D5 B0 BB C3 29 B6 以下全是加密内容 8C 78 6F CA 66 0B 4A 21 47 77 DA E7 47 AE 04 09 B8 FD 5E A4 37 0E DF F9 9B 4D 85 D6 89 17 8A F5 70 81 9A 66 AF 61 A7 F1 3D E9 E8 64 86 BC 1F D8 9C 64 06 AC 51 22 E9 95 2B 96 以上全是加密内容 00 18 00 16 00 01 0825Data0 00 00 04 53 00 00 00 01 00 00 15 79 0825Data2 6A 4E AC D5 QQ 00 01 00 00 01 03 00 14 00 01 00 10 97 25 CE F1 4D 99 CD67 C9 58 BE DB 5F 06 64 53 01 10 00 3C 00 01 00 38 B4 A7 令牌开始 CC 61 48 CB 10 22 CE AD 5A 8B 92 7C 64 14 40 B5 79 AA DB 60 A0 3F 8A DB 12 37 FB 31 9F C9 2E EB CD 69 93 8F 97 5C 93 22 2B CF BC 2D 73 25 7E 6E 4D 73 A0 C1 DD 66 令牌结束 05 07 00 11 01 97 23 B9 72 5C 59 AA 23 51 AB E5 0A 35 8A4D 3B 固定 00 32 00 63 固定 3E 00 63 02 04 03 04 01 00 04 00 58 56 00 00 00 00 31 27D7 14 2F 93 7E 10 6F 2A 51 29 AC 54 50 29 03 01 00 00 67 FD 15 79 00 00 01 0200 00 00 00 07 DE 00 03 00 06 00 01 00 04 00 03 00 04 20 5C 00 固定 93 76 BB 9A 07 0F CF 47 71 A0 2B 47 52 BB 14 2F 0B C5 DDF7 A7 7E BD 2A 23 B0 37 69 3B DC 1B 6C MD5_32(算法不明)68 03 12 00 05 01 00 00 0001 05 08 00 05 01 00 00 00 0003 13 00 19 01 01 02 00 10 7D 7B EF 63 A2 63 09 46 26 09 1D ED 8E 89 BD 47 00 00 00 固定内容 在此定义为Fix3 10 01 代表无需验证码（如果需要验证码则为0F 01） 02 00 62 00 01 固定内容 58 63 E8 59 39 75 DC 43 6C 47 63 F3 CA 21 38 8C 0836Key2 00 38 固定 FB 0836Token DA 66 39 8D 9B 00 13 44 E5 13 45 B1 D6 D9 6D 06 A8 2F 46 29 7A 49 85 07 53 A5 00 2B 64 3D 15 8F 8D 01 4A B2 23 84 31 EA F1 F6 8F FC 7C 52 BC EA 8C D8 4D 0C E7 BE F1 ---------- 00 14 48 7E 97 7F A6 74 1F A2 D1 39 E8 D7 EC E8 2F B9 crc32Data 3890 C1 2F 00BA验证码获取： 02 36 61 00 BA 5C 2F 97 91 CF 4D qq 03 00 00 00 01 01 01 00 00 67 FD 00 00 00 00 EA 40 FD FA 13 8C 05 56 E2 B4 0B 12 86 81 BB F9 BaKey AB 8E 32 22 EB 84 红字全为加密的数据，可使用BaKey解密 0B CB F9 C1 2F 8C 42 09 8F 34 94 71 FB CF BD 50 46 74 F6 FD B0 30 91 A1 91 9A 24 EE 2A AE 82 4A 01 B2 3E 7D F4 C5 00 8F FA 3E 5E 7A 2D 9F 1D 15 A0 13 60 57 8D 75 6E EC 9A 95 F7 EA E9 A0 E5 78 AA F5 68 A7 B3 3E 7B 41 A2 6C 88 EF D3 24 AB F1 36 08 E9 5C D0 56 9B F3 65 45 17 35 1D 71 2B 59 E8 8B C0 63 08 63 2C A4 3A 03 3C 4C BC D4 46 14 26 32 74 71 EF 94 38 D9 43 2B 97 D9 18 BA E8 3C 9F 27 A0 99 0F 97 70 5A 99 07 4F 7D 13 E2 CE 66 83 F9 C0 27 04 40 FB BC E2 33 75 BB 81 44 B2 01 6E 2C D3 00 25 4E ED AC D2 30 74 B6 58 E2 F2 78 E2 67 05 7C 31 D5 2B B0 FE AF 03 解密结果： 00 02 00 00 08 04 01 E0 这些都可以固定 00 00 04 53 00 00 00 01 00 00 15 79 0825Data2 00 00 38 固定 BB E4 28 C2 42 0A 0B 42 A7 m_0825token C4 86 AC F8 29 4B CE E3 E9 51 D4 77 8B 08 37 A2 D2 1C 53 88 D4 2D 9D BB 39 98 DA DA 43 35 6C 59 03 07 BD 4E 6E 22 C3 B3 17 29 6E 33 90 A3 E6 01 02 00 19 这些固定 03 7A 28 54 39 E1 9E CC 90 1B 86 FC EB 7F F0 F0 95 6B 54 6E EB 9F E0 71 EE ecdhkey 13 00 05 00 00 00 00 01 sequence 00 28 固定 EE 2E AA 1D 77 92 AA BC 32 2C 00BaToken D4 18 96 35 08 B1 4F 86 54 EF F5 24 9A 21 2F 79 6D 03 89 7A FE C4 7E 44 B6 E2 1E AE F8 59 00 10 97 25 CE F1 4D 99 CD 67 C9 58 BE DB 5F 06 64 53 这是一个密匙，这里定义为00BAKey1 0836成功接收包 02 包头 36 61 版本 08 36 指令 66 78 标识 6A 4E AC D5 QQ 00 00 00 81 12 加密的内容，使用decodekey进行第一次解密之后再用新的tgtgkey进行解密 2E 65 B4 E8 61 1C D2 E6 0D 2C 9F 30 AD A1 9D 21 03 D5 8E 8E 34 1E 5F 33 F4 B1 75 F3 23 C6 A0 90 23 9D 06 6B F5 24 76 2D 9F 59 E4 D9 9B 81 3E 85 B6 53 55 EE C9 45 0B 9D 10 D9 4D 39 13 6C 3C 07 56 1A 54 79 0A 74 3B B1 E9 8E DE 6D 54 B8 F7 68 B1 C5 AF 65 4F 8E 03 BF 9B 35 ED EA A3 BC D3 EF 97 2C 68 3C 36 ED 4A 7D 5F DF D4 98 BF 5A 5F 87 88 E4 54 67 27 68 69 26 46 5F DD 7D 70 96 B6 A2 FE 78 58 9B B4 BB FC AA A9 5C 3F 1F 3D 0C FF D1 D6 D8 AE 47 A1 35 FB D5 81 52 20 AC C8 71 BD D6 AA 8F 11 68 5C 79 75 8C E6 23 7C 4C 36 98 D5 B4 90 42 B8 B5 45 EB 13 F5 70 FB 4B 92 E5 3A A5 78 60 5F DF 6F 00 A8 61 E9 44 F4 2D 05 1B 3E DE E2 DD 1F E3 71 F8 05 EF 13 6F D8 06 35 2E 98 3D DC 56 5C 08 6B 95 B5 41 16 DF 4E E8 E9 1F 6C 52 87 68 EF 2C E9 C5 C2 17 F1 DD 8B 6B D0 0E 0A 22 A3 F1 39 44 59 A3 3E A9 33 2F A1 DB 28 CB C7 2E B6 9B E3 DC 56 AA B5 AA BF 56 87 3B C4 55 D6 A9 79 F4 F3 4C 84 B8 07 F4 36 29 7E F2 18 9E 23 89 44 FA B5 B6 A6 22 45 2F 71 9E 78 03 91 E3 BA 4B A5 34 85 74 24 32 B3 81 45 0B 38 97 BB 56 D0 A1 15 E7 5B 4A CD 5C 7E D1 2A E0 72 FF 5C 61 0F 2A A3 77 1E 9F D0 0D 52 7B 30 E2 E1 ED 8F D1 0F 74 40 BD 9B 70 7E CA 57 3B 96 61 39 3D 41 5B E6 37 15 1A 9D 06 A3 EF 29 86 41 9C 0A B6 29 3A 39 58 18 F3 D8 5C 3C A3 EC CD CC 70 9A 81 20 4E C5 1A 1D C7 BD E0 D8 8F 96 9D B7 D4 8D DE 0F A5 3E CD BE 87 53 04 52 F9 A0 71 0B 06 66 64 29 14 0E 07 12 DE 58 7B D8 8C C9 CD 20 DC 64 DE 0F 9B 11 F4 65 56 27 0E 02 E0 A6 53 66 47 3E 80 82 6B E7 1C 75 06 9E B6 62 44 F7 AA C9 DC 51 85 5B F8 42 81 03 5E CA A5 CD CC 2F 1A F1 C8 3C 11 56 85 14 BA 9A 40 7F DB C6 C7 DD 11 9D B1 D9 AA AD 6C CA 76 5A E8 D7 10 F0 35 9E F1 16 F1 36 17 BF 7E 37 57 02 9E 24 94 02 54 F4 34 82 CD 84 FE FF FD 15 6B D7 B7 76 08 36 E0 EA 55 6F E6 F7 10 F3 43 65 17 92 07 76 A2 61 DB FE 0B A2 35 BC 8B 70 33 FB 5A 81 C4 32 C1 51 C4 DE 0C 7A BC 7E 9C 14 63 06 F9 02 81 F1 0C 83 C4 26 A8 05 FA 03 D1 12 2D DA 87 30 26 18 50 F5 5F 2D A1 3C 64 2B 81 5E 12 A0 2A CF 80 EF 21 88 7D E7 01 C6 1D 85 8D 37 60 5B B4 1B F4 D9 92 30 2D 3C A7 92 56 80 1C D2 C9 F3 DC 41 4B F8 53 6D 1A 11 80 47 47 4A 95 6F CF 1C C3 D3 D8 EB 45 74 67 79 16 92 8F 3D 8B DF B0 CF 48 81 E7 DF E0 08 B1 50 2C 7E 8A 01 0C 4E 89 B0 03 解密的结果为： * m_0828_rec_decr_key：38 42 75 51 34 24 4E 37 44 2C 3E 60 2E 52 2A 60 * nick_length：03 * m_nick：E6 A2 A6 * m_age：02 78 * m_gender：02 * 38Token：D4 40 93 9D B1 84 82 F9 92 F4 A2 46 02 41 CD DD 1A E3 2B 48 1E52 F1 0E 80 FB 22 C9 17 20 E1 EC 9C CB CA 76 F3 A2 A0 29 94 16 22 B0 35 FF FDE6 41 9F 57 71 43 D8 DF 2B* 88Token：00 04 5B F2 C5 E5 70 31 77 12 00 00 00 00 00 78 08 29 E0 22 8E1A 80 58 45 5C D9 F4 F9 B0 9A D0 69 CE 3E 0E 7F 7F 4C 81 05 3B 4E CA B2 D1 1A3C 8A 97 B6 76 7F 99 8A 19 74 49 EE 5A 52 F2 FB 60 A0 8E 35 F5 3B 01 7A 24 9C04 94 FD 6F 1C 06 27 69 9D DF 67 02 0A 59 B6 21 1A A5 23 AF 39 05 CA DB 47 7A75 A8 47 12 4E EF 28 3E AA 77 C5 59 A7 B4 08 26 F0 FE 82 75 A3 EF 44 DB 0E BACC F6 2E 0D 2B 05 06 FE C7 76 B0 * Key：DB 20 0D 2E E3 EC 17 F5 49 C1 8F E8 91 F6 9F 72（用来加密0828发送包的） 00 01 09 00 70 00 01 DB 20 0D 2E E3 EC 17 F5 49 C1 8F E8 91 F6 9F 72 0038 D4 40 93 9D B1 84 82 F9 92 F4 A2 46 02 41 CD DD 1A E3 2B 48 1E 52 F1 0E 80FB 22 C9 17 20 E1 EC 9C CB CA 76 F3 A2 A0 29 94 16 22 B0 35 FF FD E6 41 9F 5771 43 D8 DF 2B 00 20 77 D7 D1 7C 49 DA 28 C5 E8 61 F2 6D D0 E2 EC 45 1A B5 D073 85 25 97 24 C8 E0 1E AF 24 B1 F7 E6 00 00 01 03 00 14 00 01 00 10 97 25 CEF1 4D 99 CD 67 C9 58 BE DB 5F 06 64 53 00 33 00 18 C4 B5 76 45 E8 8D 76 F5 289B A8 F0 D6 AA 21 BB 48 E3 A7 47 DA C2 77 FC 01 07 01 D3 00 01 00 16 00 00 0001 00 00 00 64 00 00 0D D6 00 09 3A 80 00 00 00 3C 00 02 38 42 75 51 34 24 4E37 44 2C 3E 60 2E 52 2A 60 00 88 00 04 5B F2 C5 E5 70 31 77 12 00 00 00 00 0078 08 29 E0 22 8E 1A 80 58 45 5C D9 F4 F9 B0 9A D0 69 CE 3E 0E 7F 7F 4C 81 053B 4E CA B2 D1 1A 3C 8A 97 B6 76 7F 99 8A 19 74 49 EE 5A 52 F2 FB 60 A0 8E 35F5 3B 01 7A 24 9C 04 94 FD 6F 1C 06 27 69 9D DF 67 02 0A 59 B6 21 1A A5 23 AF39 05 CA DB 47 7A 75 A8 47 12 4E EF 28 3E AA 77 C5 59 A7 B4 08 26 F0 FE 82 75A3 EF 44 DB 0E BA CC F6 2E 0D 2B 05 06 FE C7 76 B0 7B 36 6B 47 3E 76 65 74 3771 3F 42 65 45 33 7B 00 78 00 01 5B F2 C5 E5 00 70 65 4E E1 DD 27 7F 9F 7E D35A F8 44 F4 3C 66 CF AB B0 BD CB 33 A7 3C 30 C1 AC D1 9F 18 3F 7B 69 A3 33 4F54 19 8B AF D7 DF 9E 73 0A AA BB 16 77 24 3B E9 F4 95 F8 21 33 47 69 C6 14 F47A A4 E5 A2 49 3D 90 95 5B 31 98 BF C2 23 FD 46 5E C5 CD 0A B4 71 3E CD 77 EFD8 03 21 6A 69 23 B7 A3 62 15 F6 AA 26 FA 4C 8D A5 4B B6 B4 9A 25 03 53 87 0083 01 7D 62 59 77 48 39 43 34 72 48 47 6E 2C 3D 45 7B 00 70 00 01 5B F2 C5 E500 68 6D 03 29 DF C0 20 A0 75 4E 23 10 CD FD 95 BA 62 1F 51 80 E5 87 C6 B3 CE25 40 4F 95 10 B6 23 B9 C6 6C 2B 24 BB C4 9D B6 25 D5 40 4C F0 7D 98 88 FB D461 16 7A 8F 2A F0 BC A9 85 55 58 7B 12 C8 0C D1 4F 97 81 85 F2 01 59 38 AC 25B4 AF 69 43 F3 8D 7F EE 0A 87 EB 16 8D AA 90 42 AE 98 A9 84 B4 19 56 63 57 A730 5B 3E 43 5D 5B 66 78 50 42 21 77 66 6D 73 4A 53 42 01 08 00 18 00 01 00 1400 0C 02 B8 03 E6 A2 A6 02 00 00 02 02 78 00 04 00 00 00 01 01 15 00 10 4A B38F D8 46 C6 89 4C 81 11 DE 62 9C 37 FF 45 0828发送包 02 36 61 版本 08 28 指令 5A 6D 标识 6A 4E AC D5 QQ号 02 00 00 00 01 01 01 00 00 67 FD 00 30 00 3A 固定 00 38 令牌长度 D4 40 93 9D B1 84 82 F9 92 F4 A2 46 02 41 CD DD 1A E3 2B 48 1E 52 F1 0E 80 FB 22 C9 17 20 E1 EC 9C CB CA 76 F3 A2 A0 29 94 16 22 B0 35 FF FD E6 41 9F 57 71 43 D8 DF 2B F0 EE 0B 25 B9 03 9C C7 F0 30 51 FC 60 70 1D 4D 34 E5 9E 66 A8 BE A2 42 5F B2 C2 1E 87 41 AD 4A 11 FE 57 FD BC 14 99 BA 5C 6C B5 5F 08 74 27 97 70 E9 58 C3 57 6A 8C C7 42 FD B0 B1 15 D5 BF 6E B3 33 CF A5 04 BB AA EF 49 01 5A 2B 40 A5 DC 1B C5 2A 7A 93 0C 4A A2 70 D2 FB 9B 33 8C 3B 04 9B 7B 4B 01 A4 3B 29 71 50 78 DA DF 66 9D F0 89 6C 99 B4 AA 4D 95 A6 43 A1 76 6A AF 9B C3 6D 54 A6 42 C7 7F 0A B5 B0 7E 63 F9 39 11 5E B9 0A 89 8A 7D 68 BA A7 02 20 8D 61 7E E8 78 BB E4 58 AD 11 04 B7 DD 93 4D CF 99 2D 52 D2 82 43 6E EE 3A F4 00 1A 56 0B 8A BC 51 A9 5E EF 84 41 71 DD 22 73 D2 84 96 47 8C D9 A5 03 7F 83 47 F8 6D B1 2F 56 02 CB D9 0A 4E 5B ED CF D0 2E F9 8E 8A AE 7E 8E E5 2A 15 9C 7D 5B E7 2E 22 6E 75 BC 4F 7E 2A 8A 2A FD 71 A9 37 5C 77 BB B1 65 BC 5D A8 AB E4 10 7E 51 FC 75 C4 8D EE 38 23 F9 5E 8E 44 62 75 35 1D B2 54 2F F0 AD CF 84 8C 11 9C 28 DF 3D E1 4A B8 A5 F3 C9 FB EC 9E 23 AB ED CE AB 5E 9A AB 6F BD 62 7B DE 4A 7D C4 74 C2 6A E7 8D 78 ED AF 16 78 D2 C4 8E D5 18 FB 16 76 5B A3 FA C4 58 51 FF 90 35 3A 1B 93 ED E4 8A 47 88 78 82 FE 32 C7 65 9E 3B 41 27 37 CB C6 BE 58 A4 2B 59 8C B5 6A 45 61 F3 02 97 B1 B8 6D 40 9A 3F 60 DD 54 66 C0 20 67 5F 2E 9C AD A2 D6 86 EF B7 78 95 36 B1 3B 1C 1E BE 63 A0 9A 7D 7C 9D 34 8F E1 4D 54 DE 42 9D DA 11 E2 7A EE A7 4B 30 9C 65 2F DD 30 7A A6 02 03 C9 FB 78 E1 FE B7 98 63 5A 21 76 AD 8A B0 DC 84 93 53 E3 6A 40 8E CB 17 7B D9 38 D0 3C DD A6 72 87 EC 14 03 9C 60 C4 53 F6 00 01 00 DE 87 45 C6 99 73 45 51 82 94 B2 DB C9 0C EE 64 AB 27 35 19 F7 A5 28 F2 93 0C 0C 9B C4 D0 B3 6F 05 A5 A1 33 A4 EA 85 18 AD A6 E4 3C 2B CE 39 9F 2F B2 12 16 49 C9 E2 85 E9 DC 74 85 2D 0B E1 5F 1C AD E3 69 64 49 9D 62 9E E1 E5 20 43 94 CB 8B 39 59 E0 49 D0 74 C1 F9 D1 1D 7C 09 95 9F 85 42 D7 79 62 04 62 01 D8 A1 F1 55 45 02 97 79 10 D7 9E F4 6B A3 1B 67 A6 4A 86 FD A1 6A EF 9B 27 B4 4C 15 AB 绿色的都是加密内容 03 解密后结果： 00 07 00 88 00 04 5B F2 C5 E5 70 31 77 12 00 00 这里都是88Token 00 00 00 78 08 29 E0 22 8E 1A 80 58 45 5C D9 F4 F9 B0 9A D0 69 CE 3E 0E 7F 7F 4C 81 05 3B 4E CA B2 D1 1A 3C 8A 97 B6 76 7F 99 8A 19 74 49 EE 5A 52 F2 FB 60 A0 8E 35 F5 3B 01 7A 24 9C 04 94 FD 6F 1C 06 27 69 9D DF 67 02 0A 59 B6 21 1A A5 23 AF 39 05 CA DB 47 7A 75 A8 47 12 4E EF 28 3E AA 77 C5 59 A7 B4 08 26 F0 FE 82 75 A3 EF 44 DB 0E BA CC F6 2E 0D 2B 05 06 FE C7 76 B0 00 0C 00 16 00 02 00 00 00 00 00 14 00 00 00 00 78 CC 11 12 这是服务器IP 1F 40 00 00 00 00 00 15 00 30 00 01 定义为Fix1 01 FF 68 9D F1 00 10 04 F1 4A AD E1 47 5B 95 DE F9 CD 5D 76 17 96 88 02 86 10 6F DD 0010 31 27 D7 14 2F 93 7E 10 6F 2A 51 29 AC 54 50 29 _0836Fix 00 36 00 12 00 02 00 01 00 00 00 05 00 00 00 00 00 00 00 00 00 00 00 18 00 16 00 01 0825Data0 00 00 04 53 00 00 00 01 00 00 15 79 0825Data2 6A 4E AC D5 QQ号 00 01 00 00 00 1F 00 22 00 01 62 72 FF A2 44 A5 43 21 DA C0 10 13 E2 9F 58 62 04 B8 96 28 CC A1 D5 7C56 1E 92 BC 34 0C 6A F3 deviceID(随机生成32位) --------------tlv0105----------------- 在获取回话密匙时下次登录会使用，如果第一次没有可以使用以下代码制取 g_tlv0105 ＝ “01 05 00 30 ” ＋ “00 01 01 02 00 14 01 01 00 10 ” ＋ GetRandomKey (16) ＋ “00 14 0102 00 10 ” ＋GetRandomKey (16) 01 05 00 88 00 01 01 02 00 40 02 01 03 3C 01 03 00 00 EB 4A EE 9E BB 10 A0 C1 7A A3 26 83 B3 28 FC 6D 0A E9 15 7F B8 2B 84 B320 AA 1A 96 EE C2 61 B1 27 0B 72 0B A8 6C 95 7E 54 88 45 1F 1A DE E1 71 45 E393 99 FA 87 90 A2 00 40 02 02 03 3C 01 03 00 00 FE C9 1A 9D 20 97 76 D0 8C D2 36 98 A5 1B 46 AB 94 27 29 91 EC 5B 94 3699 49 39 3C DA A2 7C 2A FF AC 48 0C 76 3B EC 89 83 92 0C 03 2D 3C 68 69 07 C9D5 09 48 37 98 5B ---------------tlv0105------------------ 01 0B 00 85 00 02 AB 5C 3C 06 9E 5A 48 9F 42 97 A2 2E E5 78 4C 4F 定义为Fix2 7D 随机获取一位‘GetRandomKey (1)’ 10 00 00 00 00 00 00 00 02 ----------fix3---------- 00 63 3E 00 63 02 04 03 04 01 00 04 00 58 56 00 00 00 00 31 27 D7 14 2F 93 7E 10 6F 2A 51 29 AC 54 50 29 03 0100 00 67 FD 15 79 00 00 01 02 00 00 00 00 07 DE 00 03 00 06 00 01 00 04 00 0300 04 20 5C 0093 76 BB 9A 07 0F CF 47 71 A0 2B 47 52 BB 14 2F 0B C5DD F7 A7 7E BD 2A 23 B0 37 69 3B DC 1B 6C MD5_32(之前随机获取的那个) 68 ------------------------- 00 00 00 00 00 2D 00 06 00 01 C0 A8 01 65 02 36 61 00 02 3D 78 6A 4E AC D5 02 00 00 00 01 01 01 00 00 67 FD 66 A6 41 52 B7 13 A7 2A 61 09 DC 25 66 E5 61 AD B8 17 15 26 35 BF A7 C7 03 C4 94 F6 AD 00 BB 49 19 00 0E 8A B7 FE 4C 6D E6 16 ED F7 CD 15 F1 ED 3D 0B 7B 00 C8 CA 09 9A 7A E8 7E B8 CC 83 DE 68 4A AB 83 FE 0C 45 31 71 68 C7 EB CD 89 5B CC CB AC 07 9E E3 F1 2D AE E9 4F 59 33 27 B8 F2 28 72 BF E0 7B C9 26 AE 5D 07 03 使用会话密匙解密结果如下： 2A 固定 38 BA 32 6C 群ID 00 55 长度 00 01 01 00 00 00 00 00 00 00 4D 53 47 00 00 00 00 00 固定 5B F8 E2 14 时间戳 34 4D D3 15 随机 00 00 00 00 0A 00 86 00 00 0C E5 BE AE E8 BD AF E9 9B 85 E9 BB 91 00 00 固定 01 00 固定 09 长度+3 01 00 固定 06 长度 E6 B5 8B E8 AF 95 消息内容 02 00 14 01 00 01 0D FF 00 02 14 4E 0B 00 08 00 01 00 04 52 CC 85 50 这应该是表情吧 02 36 61 00 CD 00 9F 6A 4E AC D5 02 00 00 00 01 01 01 00 00 67 FD 以上这些都是固定模式：包头+版本+命令标识+QQ+fixVer 9B 37 40 47 B8 93 02 1F 64 49 60 57 D8 79 4B 15 1C 62 8A 5D 9E B2 79 ED F8 F0 A0 DA CE FC 77 E1 EA 89 C9 84 53 18 95 3E 3F 23 E5 87 DB 62 E1 10 B2 CB 4C B0 FF A7 66 1A D7 DE A8 9E 42 6D 79 EF 4A 0A 24 EA 00 35 3C 7D 40 46 A6 C1 D1 D5 55 51 24 76 02 50 B3 13 F2 66 B5 8E 01 4D AA B6 6A DE 5F DD DB 1E AC 77 EE BD 19 C5 B9 5A F1 4A B8 E6 1A ED 06 42 07 2E 4B F5 00 72 70 AA 0F 59 51 BC 2F 25 71 45 6A 79 E9 47 8C D0 2E 02 6C F4 C1 31 D3 C3 FD 6A ED 70 42 37 26 5D 76 65 F2 6A CF 61 这些是加密的内容，使用会话密匙解密 03 解密结果; 6A 4E AC D5 发送者QQ 03 F6 98 06 接收者QQ 00 00 00 0D 00 01 00 04 00 00 00 00 00 03 00 01 01 36 61 固定 6A 4E AC D5 发送者QQ 03 F6 98 06 接收者QQ 51 AE 02 2E F2 C2 97 AA 5E 55 F8 70 68 10 19 AF 00 0B 6F EF 固定 5B F8 E2 08 时间戳 02 B8 00 00 00 00 01 00 00 00 01 4D 53 47 00 00 00 00 00 5B F8 E2 08 时间戳 72 6F 3C 52 随机 00 00 00 00 0A 00 86 00 00 0C E5 BE AE E8 BD AF E9 9B 85 E9 BB 91 00 00 01 00 固定 一般在长度前 09 消息长度+3 01 00 固定 一般在长度前 06 消息长度 E6 B5 8B E8 AF 95 消息内容 02 00 14 01 00 01 这玩意应该是表情 0D FF 00 02 14 4E 0B 00 08 00 01 00 04 52 CC 85 50 ","link":"https://kafuuneko.me/post/JHP7BjZhA/"}]}